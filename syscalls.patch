diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 5aef183e2f85..43775dbf25aa 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -339,6 +339,13 @@
 330	common	pkey_alloc		sys_pkey_alloc
 331	common	pkey_free		sys_pkey_free
 332	common	statx			sys_statx
+333	common	pidfdopen		sys_pidfdopen
 334	common	map_readlink		sys_map_readlink
+335	common	pidfdinfo		sys_pidfdinfo
+336	common	fdmap			sys_fdmap
+337	common	pidmap			sys_pidmap
 338	common	map_open		sys_map_open
+339	common	pidinfo			sys_pidinfo
 
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
diff --git a/fs/Kconfig b/fs/Kconfig
index 7aee6d699fd6..7dd244858d2b 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -95,6 +95,13 @@ config MANDATORY_FILE_LOCKING
 
 	  To the best of my knowledge this is dead code that no one cares about.
 
+config FDMAP
+	bool "fdmap() system call" if EXPERT
+	default y
+	help
+	  Enable fdmap() system call that allows to query file descriptors
+	  in binary form avoiding /proc overhead.
+
 source "fs/crypto/Kconfig"
 
 source "fs/notify/Kconfig"
diff --git a/fs/file.c b/fs/file.c
index 4eecbf4244a5..003fc37e8c3e 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -972,3 +972,104 @@ int iterate_fd(struct files_struct *files, unsigned n,
 	return res;
 }
 EXPORT_SYMBOL(iterate_fd);
+
+#ifdef CONFIG_FDMAP
+/**
+ * fdmap - get opened file descriptors of a process
+ * @pid: the pid of the target process
+ * @fds: allocated userspace buffer
+ * @count: buffer size (in descriptors)
+ * @start_fd: first descriptor to search from (inclusive)
+ * @flags: reserved for future functionality, must be zero
+ *
+ * If @pid is zero then it's current process.
+ * Return: number of descriptors written. An error code otherwise.
+ */
+SYSCALL_DEFINE5(fdmap, pid_t, pid, int __user *, fds, unsigned int, count,
+		int, start_fd, int, flags)
+{
+	struct task_struct *task;
+	struct files_struct *files;
+	unsigned long search_mask;
+	unsigned int user_index, offset;
+	int masksize;
+
+	if (start_fd < 0 || flags != 0)
+		return -EINVAL;
+
+	if (!pid) {
+		files = get_files_struct(current);
+	} else {
+		rcu_read_lock();
+		task = find_task_by_vpid(pid);
+		if (!task) {
+			rcu_read_unlock();
+			return -ESRCH;
+		}
+		if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
+			rcu_read_unlock();
+			return -EACCES;
+		}
+		files = get_files_struct(task);
+		rcu_read_unlock();
+	}
+	if (!files)
+		return 0;
+
+	offset = start_fd / BITS_PER_LONG;
+	search_mask = ULONG_MAX << (start_fd % BITS_PER_LONG);
+	user_index = 0;
+#define FDS_BUF_SIZE	(512/sizeof(unsigned long))
+	masksize = FDS_BUF_SIZE;
+	while (user_index < count && masksize == FDS_BUF_SIZE) {
+		unsigned long open_fds[FDS_BUF_SIZE];
+		struct fdtable *fdt;
+		unsigned int i;
+
+		/*
+		 * fdt->max_fds can grow, get it every time
+		 * before copying part into internal buffer.
+		 */
+		rcu_read_lock();
+		fdt = files_fdtable(files);
+		masksize = fdt->max_fds / 8 - offset * sizeof(long);
+		if (masksize < 0) {
+			rcu_read_unlock();
+			break;
+		}
+		masksize = min(masksize, (int)sizeof(open_fds));
+		memcpy(open_fds, fdt->open_fds + offset, masksize);
+		rcu_read_unlock();
+
+		open_fds[0] &= search_mask;
+		search_mask = ULONG_MAX;
+		masksize = (masksize + sizeof(long) - 1) / sizeof(long);
+		start_fd = offset * BITS_PER_LONG;
+		/*
+		 * for_each_set_bit_from() can re-read first word
+		 * multiple times which is not optimal.
+		 */
+		for (i = 0; i < masksize; i++) {
+			unsigned long mask = open_fds[i];
+
+			while (mask) {
+				unsigned int real_fd = start_fd + __ffs(mask);
+
+				if (put_user(real_fd, fds + user_index)) {
+					put_files_struct(files);
+					return -EFAULT;
+				}
+				if (++user_index >= count)
+					goto out;
+				mask &= mask - 1;
+			}
+			start_fd += BITS_PER_LONG;
+		}
+		offset += FDS_BUF_SIZE;
+	}
+out:
+	put_files_struct(files);
+
+	return user_index;
+}
+#endif
diff --git a/fs/open.c b/fs/open.c
index 7ea118471dce..72eb58a18dac 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -31,6 +31,7 @@
 #include <linux/ima.h>
 #include <linux/dnotify.h>
 #include <linux/compat.h>
+#include <linux/sched/mm.h>
 
 #include "internal.h"
 
@@ -1206,3 +1207,308 @@ int nonseekable_open(struct inode *inode, struct file *filp)
 }
 
 EXPORT_SYMBOL(nonseekable_open);
+
+SYSCALL_DEFINE3(pidfdopen, pid_t, pid, int, fd, int, flags)
+{
+	struct open_flags op;
+	struct task_struct *task;
+	struct files_struct *files;
+	struct fdtable *fdt;
+	struct file *filp, *newfilp;
+	int newfd, error;
+
+	if (fd < 0 || pid < 1)
+		return -EINVAL;
+	if (build_open_flags(flags, 0, &op) < 0)
+		return -EINVAL;
+
+	rcu_read_lock();
+	task = find_task_by_vpid(pid);
+	if (!task) {
+		rcu_read_unlock();
+		return -ESRCH;
+	}
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
+		rcu_read_unlock();
+		return -EACCES;
+	}
+	files = get_files_struct(task);
+	if (!files) {
+		rcu_read_unlock();
+		return -EBADF;
+	}
+	fdt = files_fdtable(files);
+	if (fd >= fdt->max_fds) {
+		put_files_struct(files);
+		rcu_read_unlock();
+		return -EBADF;
+	}
+	filp = fdt->fd[fd];
+	if (!filp) {
+		put_files_struct(files);
+		rcu_read_unlock();
+		return -EBADF;
+	}
+	get_file_rcu(filp);
+	put_files_struct(files);
+	rcu_read_unlock();
+
+	newfd = get_unused_fd_flags(flags);
+	if (newfd < 0) {
+		fput(filp);
+		return newfd;
+	}
+
+	newfilp = get_empty_filp();
+	if (IS_ERR(newfilp)) {
+		put_unused_fd(newfd);
+		fput(filp);
+		return PTR_ERR(newfilp);
+	}
+	newfilp->f_flags = op.open_flag;
+
+	error = vfs_open(&filp->f_path, newfilp, current_cred());
+	fput(filp);
+	if (error) {
+		put_unused_fd(newfd);
+		put_filp(newfilp);
+		return error;
+	}
+
+	fsnotify_open(newfilp);
+	fd_install(newfd, newfilp);
+
+	return newfd;
+}
+
+static __u64 fdinfo_flags(struct file *filp, struct fdtable *fdt)
+{
+	__u64 result = 0;
+
+	if ((filp->f_flags & O_ACCMODE) == O_RDONLY)
+		result |= FDINFO_RDONLY;
+	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
+		result |= FDINFO_WRONLY;
+	if ((filp->f_flags & O_ACCMODE) == O_RDWR)
+		result |= FDINFO_RDWR;
+	if (filp->f_flags & O_CREAT)
+		result |= FDINFO_CREAT;
+	if (filp->f_flags & O_EXCL)
+		result |= FDINFO_EXCL;
+	if (filp->f_flags & O_NOCTTY)
+		result |= FDINFO_NOCTTY;
+	if (filp->f_flags & O_TRUNC)
+		result |= FDINFO_TRUNC;
+	if (filp->f_flags & O_APPEND)
+		result |= FDINFO_APPEND;
+	if (filp->f_flags & O_NONBLOCK)
+		result |= FDINFO_NONBLOCK;
+	if (filp->f_flags & O_DSYNC)
+		result |= FDINFO_DSYNC;
+	if (filp->f_flags & FASYNC)
+		result |= FDINFO_FASYNC;
+	if (filp->f_flags & O_DIRECT)
+		result |= FDINFO_DIRECT;
+	if (filp->f_flags & O_LARGEFILE)
+		result |= FDINFO_LARGEFILE;
+	if (filp->f_flags & O_DIRECTORY)
+		result |= FDINFO_DIRECTORY;
+	if (filp->f_flags & O_NOFOLLOW)
+		result |= FDINFO_NOFOLLOW;
+	if (filp->f_flags & O_NOATIME)
+		result |= FDINFO_NOATIME;
+	if (filp->f_flags & O_CLOEXEC)
+		result |= FDINFO_CLOEXEC;
+	if (filp->f_flags & O_SYNC)
+		result |= FDINFO_SYNC;
+	if (filp->f_flags & O_PATH)
+		result |= FDINFO_PATH;
+	if (filp->f_flags & O_TMPFILE)
+		result |= FDINFO_TMPFILE;
+	if (d_unlinked(filp->f_path.dentry))
+		result |= FDINFO_FD_DELETED;
+	return result;
+}
+SYSCALL_DEFINE4(pidfdinfo, pid_t, pid, int, fd,
+		struct fdinfo __user *, buffer, unsigned int, size)
+{
+	struct task_struct *task;
+	struct files_struct *files;
+	struct file *filp;
+	struct fdtable *fdt;
+	struct path root;
+	__u64 flags = 0;
+	size_t path_size = 0, writed_size = 0;
+	char *buf, *path;
+
+	if (fd < 0 || pid < 1)
+		return -EINVAL;
+
+	rcu_read_lock();
+	task = find_task_by_vpid(pid);
+	if (!task) {
+		rcu_read_unlock();
+		return -ESRCH;
+	}
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
+		rcu_read_unlock();
+		return -EACCES;
+	}
+	files = get_files_struct(task);
+	if (!files) {
+		rcu_read_unlock();
+		return -EBADF;
+	}
+	fdt = files_fdtable(files);
+	if (fd >= fdt->max_fds) {
+		put_files_struct(files);
+		rcu_read_unlock();
+		return -EBADF;
+	}
+	filp = fdt->fd[fd];
+	if (!filp) {
+		put_files_struct(files);
+		rcu_read_unlock();
+		return -EBADF;
+	}
+	get_file_rcu(filp);
+	put_files_struct(files);
+	rcu_read_unlock();
+
+	flags = fdinfo_flags(filp, fdt);
+	if (size < sizeof(buffer->flags)) {
+		fput(filp);
+		return writed_size;
+	}
+	if (put_user(flags, &(buffer->flags))) {
+		fput(filp);
+		return -EFAULT;
+	}
+	writed_size += sizeof(buffer->flags);
+	size -= sizeof(buffer->flags);
+	if (size < sizeof(buffer->pos)) {
+		fput(filp);
+		return writed_size;
+	}
+	if (put_user(filp->f_pos, &(buffer->pos))) {
+		fput(filp);
+		return -EFAULT;
+	}
+	writed_size += sizeof(buffer->pos);
+	size -= sizeof(buffer->pos);
+	if (!size) {
+		fput(filp);
+		return writed_size;
+	}
+	buf = (char *)__get_free_page(GFP_KERNEL);
+	if (!buf) {
+		fput(filp);
+		return -ENOMEM;
+	}
+
+	get_fs_root(current->fs, &root);
+	path = __d_path(&(filp->f_path), &root, buf, PAGE_SIZE);
+	fput(filp);
+
+	if (path && !IS_ERR(path))
+		path_size = buf + PAGE_SIZE - 1 - path;
+	if (path && path_size <= size) {
+		if (copy_to_user(&(buffer->path), path, path_size)) {
+			free_page((unsigned long)buf);
+			return -EFAULT;
+		}
+		writed_size += path_size;
+	}
+	free_page((unsigned long)buf);
+	return writed_size;
+}
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index a78186d826d7..522d95995810 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -80,6 +80,9 @@ union bpf_attr;
 #include <linux/quota.h>
 #include <linux/key.h>
 #include <trace/syscall.h>
+#include <linux/taskinfo.h>
+#include <linux/credinfo.h>
+#include <linux/vminfo.h>
 
 /*
  * __MAP - apply a macro to syscall arguments
@@ -940,5 +943,39 @@ asmlinkage long sys_pkey_alloc(unsigned long flags, unsigned long init_val);
 asmlinkage long sys_pkey_free(int pkey);
 asmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags,
 			  unsigned mask, struct statx __user *buffer);
+asmlinkage long sys_pidfdopen(pid_t pid, int fd, int flags);
+asmlinkage long sys_pidfdinfo(pid_t pid,
+			      int fd,
+			      struct fdinfo __user *buffer,
+			      unsigned int size);
+asmlinkage long sys_pidinfo(pid_t pid, unsigned long mode,
+			    struct taskinfo __user *buffer);
+asmlinkage long sys_fdmap(pid_t pid,
+			  int __user *fds,
+			  unsigned int count,
+			  int start_fd,
+			  int flags);
+asmlinkage long sys_pidmap(pid_t pid,
+			   int __user *pids,
+			   unsigned int pids_count,
+			   unsigned int start_pid,
+			   int flags);
+
 asmlinkage long sys_credinfo(pid_t pid,
 			     struct credinfo __user *buffer,
 			     unsigned int size,
diff --git a/include/uapi/linux/taskinfo.h b/include/uapi/linux/taskinfo.h
new file mode 100644
index 000000000000..1287d5497a0d
--- /dev/null
+++ b/include/uapi/linux/taskinfo.h
@@ -0,0 +1,72 @@
+#ifndef _LINUX_TASKINFO_H_
+#define _LINUX_TASKINFO_H_
+
+#include <linux/types.h>
+
+#define TASKINFO_STATE_RUNNING		0
+#define TASKINFO_STATE_SLEEPING		1
+#define TASKINFO_STATE_DISK_SLEEP	2
+#define TASKINFO_STATE_STOPPED		3
+#define TASKINFO_STATE_TRACED		4
+#define TASKINFO_STATE_DEAD		5
+#define TASKINFO_STATE_ZOMBIE		6
+#define TASKINFO_STATE_PARKED		7
+#define TASKINFO_STATE_IDLE		8
+
+#define PIDMAP_TASKS		1
+#define PIDMAP_PROC		2
+#define PIDMAP_CHILDREN		3
+#define PIDMAP_THREADS		4
+#define PIDMAP_IGNORE_KTHREADS (1 << 30)
+
+#define TASKINFO_COMM_LEN	32
+
+#define FDINFO_RDONLY		(1ULL <<  0)
+#define FDINFO_WRONLY		(1ULL <<  1)
+#define FDINFO_RDWR		(1ULL <<  2)
+#define FDINFO_CREAT		(1ULL <<  3)
+#define FDINFO_EXCL		(1ULL <<  4)
+#define FDINFO_NOCTTY		(1ULL <<  5)
+#define FDINFO_TRUNC		(1ULL <<  6)
+#define FDINFO_APPEND		(1ULL <<  7)
+#define FDINFO_NONBLOCK		(1ULL <<  8)
+#define FDINFO_DSYNC		(1ULL <<  9)
+#define FDINFO_FASYNC		(1ULL << 10)
+#define FDINFO_DIRECT		(1ULL << 11)
+#define FDINFO_LARGEFILE	(1ULL << 12)
+#define FDINFO_DIRECTORY	(1ULL << 13)
+#define FDINFO_NOFOLLOW		(1ULL << 14)
+#define FDINFO_NOATIME		(1ULL << 15)
+#define FDINFO_CLOEXEC		(1ULL << 16)
+#define FDINFO_SYNC		(1ULL << 17)
+#define FDINFO_PATH		(1ULL << 18)
+#define FDINFO_TMPFILE		(1ULL << 19)
+#define FDINFO_FD_DELETED	(1ULL << 20)
+
+struct fdinfo {
+	__u64	pos;
+	__u64	flags;
+	char	path[1];
+};
+
+struct taskinfo {
+	/* 0x00 */
+	char comm[TASKINFO_COMM_LEN];
+	/* 0x20 */
+	__u32	state;
+	__u32	umask;
+	__u32	tgid;
+	__u32	ngid;
+	/* 0x30 */
+	__u64	utime;
+	__u64	stime;
+	__u64	cutime;
+	__u64	cstime;
+	/* 0x50 */
+	__u32	pid;
+	__u32	ppid;
+	__u32	tracer_id;
+	__u32	num_threads;
+};
+
+#endif /* _LINUX_TASKINFO_H_ */
diff --git a/init/Kconfig b/init/Kconfig
index 3c1faaa2af4a..2f3584bbcbaf 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1409,6 +1409,13 @@ config EMBEDDED
 	  an embedded system so certain expert options are available
 	  for configuration.
 
+config PIDMAP
+	bool "pidmap() system call" if EXPERT
+	default y
+	help
+	  Enable pidmap() system call that allows to query PIDs in binary form
+	  avoiding /proc overhead.
+
 config HAVE_PERF_EVENTS
 	bool
 	help
diff --git a/kernel/Makefile b/kernel/Makefile
index 172d151d429c..4543ad2f0eb7 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -101,6 +103,7 @@ obj-$(CONFIG_TRACEPOINTS) += trace/
 obj-$(CONFIG_IRQ_WORK) += irq_work.o
 obj-$(CONFIG_CPU_PM) += cpu_pm.o
 obj-$(CONFIG_BPF) += bpf/
+obj-$(CONFIG_PIDMAP) += pidmap.o
 
 obj-$(CONFIG_PERF_EVENTS) += events/
 
diff --git a/kernel/pidmap.c b/kernel/pidmap.c
new file mode 100644
index 000000000000..d984ad17577c
--- /dev/null
+++ b/kernel/pidmap.c
@@ -0,0 +1,350 @@
+#include <linux/bitops.h>
+#include <linux/cred.h>
+#include <linux/kernel.h>
+#include <linux/pid.h>
+#include <linux/ptrace.h>
+#include <linux/rcupdate.h>
+#include <linux/syscalls.h>
+#include <linux/sched.h>
+#include <linux/uaccess.h>
+#include <linux/fs_struct.h>
+#include <linux/taskinfo.h>
+#include <linux/sched/cputime.h>
+#include <linux/sched/numa_balancing.h>
+
+#define PIDMAP_PARAM	(~PIDMAP_IGNORE_KTHREADS)
+
+static inline bool pidmap_perm(const struct pid_namespace *pid_ns)
+{
+	return pid_ns->hide_pid < HIDEPID_INVISIBLE
+		|| in_group_p(pid_ns->pid_gid);
+}
+
+static bool skip_task(struct task_struct *task, bool has_perms, int flags)
+{
+	int param = flags & PIDMAP_PARAM;
+
+	if (!task)
+		return true;
+	if (!has_perms && !ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
+		return true;
+	if ((flags & PIDMAP_IGNORE_KTHREADS) && (task->flags & PF_KTHREAD))
+		return true;
+	if (param == PIDMAP_PROC && !thread_group_leader(task))
+		return true;
+	return false;
+}
+
+static long pidmap_tasks(int __user *pids, unsigned int count,
+		  unsigned int start, int flags)
+{
+	struct pid_namespace *pid_ns = task_active_pid_ns(current);
+	unsigned int start_page, start_elem;
+	unsigned int last_pos = 0;
+	unsigned int last_set_pid = 0;
+	unsigned long mask;
+	bool has_perms;
+	unsigned int i;
+
+	/*
+	 * Pid 0 does not exist, however, corresponding bit is always set in
+	 * ->pidmap[0].page, so we should skip it.
+	 */
+	if (start == 0)
+		start = 1;
+
+	if (start > pid_ns->last_pid)
+		return 0;
+
+	has_perms = pidmap_perm(pid_ns);
+
+	start_page = start / BITS_PER_PAGE;
+	start_elem = (start % BITS_PER_PAGE) / BITS_PER_LONG;
+	mask = ~0UL << (start % BITS_PER_LONG);
+
+	for (i = start_page; i < PIDMAP_ENTRIES; i++) {
+		unsigned int j;
+
+		/*
+		 * ->pidmap[].page is set once to a valid pointer,
+		 *  therefore do not take any locks.
+		 */
+		if (!pid_ns->pidmap[i].page)
+			continue;
+
+		for (j = start_elem; j < PAGE_SIZE/sizeof(unsigned long); j++) {
+			unsigned long val;
+
+			val = *((unsigned long *)pid_ns->pidmap[i].page + j);
+			val &= mask;
+			mask = ~0UL;
+			while (val != 0) {
+				struct task_struct *tsk;
+
+				if (last_pos == count)
+					return last_pos;
+
+				last_set_pid = i * BITS_PER_PAGE +
+					j * BITS_PER_LONG + __ffs(val);
+
+				rcu_read_lock();
+				tsk = find_task_by_pid_ns(last_set_pid, pid_ns);
+				if (skip_task(tsk, has_perms, flags)) {
+					rcu_read_unlock();
+					goto next;
+				}
+				rcu_read_unlock();
+
+				if (put_user(last_set_pid, pids + last_pos))
+					return -EFAULT;
+				last_pos++;
+				if (last_set_pid == pid_ns->last_pid)
+					return last_pos;
+next:
+				val &= (val - 1);
+			}
+		}
+		start_elem = 0;
+	}
+	if (last_set_pid == 0)
+		return 0;
+	else
+		return last_pos;
+}
+
+static struct task_struct *pidmap_get_task(pid_t pid, bool *has_perms)
+{
+	struct pid_namespace *pid_ns;
+	struct task_struct *task;
+
+	if (pid == 0) {
+		*has_perms = true;
+		return current;
+	}
+
+	pid_ns = task_active_pid_ns(current);
+	task = find_task_by_pid_ns(pid, pid_ns);
+	if (!task)
+		return ERR_PTR(-ESRCH);
+	*has_perms = pidmap_perm(pid_ns);
+	if (!*has_perms && !ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
+		return ERR_PTR(-EACCES);
+	return task;
+}
+
+static long pidmap_children(pid_t pid, int __user *upid,
+			    unsigned int count, unsigned int start)
+{
+	struct task_struct *task, *child;
+	bool has_perms;
+	int pids[64];
+	unsigned int i;
+	unsigned int ret;
+
+	rcu_read_lock();
+	task = pidmap_get_task(pid, &has_perms);
+	if (IS_ERR(task)) {
+		rcu_read_unlock();
+		return PTR_ERR(task);
+	}
+
+	i = 0;
+	ret = 0;
+	list_for_each_entry(child, &task->children, sibling) {
+		if (start) {
+			start--;
+			continue;
+		}
+
+		if (!has_perms &&
+		    !ptrace_may_access(child, PTRACE_MODE_READ_FSCREDS))
+			continue;
+
+		pids[i++] = child->tgid;
+		if (i >= ARRAY_SIZE(pids)) {
+			get_task_struct(task);
+			get_task_struct(child);
+			rcu_read_unlock();
+
+			if (copy_to_user(upid, pids, i * sizeof(int))) {
+				put_task_struct(child);
+				put_task_struct(task);
+				return -EFAULT;
+			}
+			upid += i;
+			ret += i;
+			i = 0;
+
+			rcu_read_lock();
+			put_task_struct(child);
+			put_task_struct(task);
+
+			if (!pid_alive(task) || !pid_alive(child))
+				break;
+		}
+		if (--count == 0)
+			break;
+	}
+	rcu_read_unlock();
+	if (i > 0) {
+		if (copy_to_user(upid, pids, i * sizeof(int)))
+			return -EFAULT;
+		ret += i;
+	}
+	return ret;
+}
+
+static long pidmap_threads(pid_t pid, int __user *upid,
+			   unsigned int count, unsigned int start)
+{
+	struct task_struct *task, *thread;
+	bool has_perms;
+	int pids[64];
+	unsigned int i;
+	unsigned int ret;
+
+	rcu_read_lock();
+	task = pidmap_get_task(pid, &has_perms);
+	if (IS_ERR(task)) {
+		rcu_read_unlock();
+		return PTR_ERR(task);
+	}
+
+	i = 0;
+	ret = 0;
+	for_each_thread(task, thread) {
+		if (start) {
+			start--;
+			continue;
+		}
+
+		pids[i++] = thread->pid;
+		if (i >= ARRAY_SIZE(pids)) {
+			get_task_struct(task);
+			get_task_struct(thread);
+			rcu_read_unlock();
+
+			if (copy_to_user(upid, pids, i * sizeof(int))) {
+				put_task_struct(thread);
+				put_task_struct(task);
+				return -EFAULT;
+			}
+			upid += i;
+			ret += i;
+			i = 0;
+
+			rcu_read_lock();
+			put_task_struct(thread);
+			put_task_struct(task);
+
+			if (!pid_alive(task) || !pid_alive(thread))
+				break;
+		}
+		if (--count == 0)
+			break;
+	}
+	rcu_read_unlock();
+	if (i > 0) {
+		if (copy_to_user(upid, pids, i * sizeof(int)))
+			return -EFAULT;
+		ret += i;
+	}
+	return ret;
+}
+
+/**
+ * pidmap - get allocated PIDs
+ * @pids: destination buffer.
+ * @count: number of elements in the buffer.
+ * @start: PID to start from or PIDs number already readed.
+ * @flags: flags.
+ *
+ * Write allocated PIDs to a buffer. @start specifies PID to start from
+ * with PIDMAP_TASKS or PIDMAP_PROC flags, or number of PIDs already
+ * readed otherwise.
+ *
+ * PIDs are filled from pid namespace of the calling process POV:
+ * unshare(CLONE_NEWPID)+fork+pidmap in child will always return 1/1.
+ *
+ * pidmap(2) hides PIDs inaccessible at /proc mounted with "hidepid" option.
+ *
+ * Note, pidmap(2) does not guarantee that any of returned PID exists
+ * by the time system call exits.
+ *
+ * Return: number of PIDs written to the buffer or error code otherwise.
+ */
+SYSCALL_DEFINE5(pidmap, pid_t, pid, int __user *, pids,
+		unsigned int, count, unsigned int, start, int, flags)
+{
+	int param = flags & PIDMAP_PARAM;
+
+	switch (param) {
+	case PIDMAP_TASKS:
+	case PIDMAP_PROC:
+		return pidmap_tasks(pids, count, start, flags);
+	case PIDMAP_CHILDREN:
+		return pidmap_children(pid, pids, count, start);
+	case PIDMAP_THREADS:
+		return pidmap_threads(pid, pids, count, start);
+	}
+	return -EINVAL;
+}
+
+SYSCALL_DEFINE3(pidinfo, pid_t, pid, unsigned long, mode,
+		struct taskinfo __user *, buffer)
+{
+	struct task_struct *task, *tracer;
+	struct user_namespace *ns;
+	struct pid_namespace *pidns = task_active_pid_ns(current);
+	struct taskinfo tinfo;
+	long flags;
+	bool has_perms;
+
+	if (mode)
+		return -EINVAL;
+
+	rcu_read_lock();
+	task = pidmap_get_task(pid, &has_perms);
+	if (IS_ERR(task)) {
+		rcu_read_unlock();
+		return PTR_ERR(task);
+	}
+	ns = get_user_ns(__task_cred(task)->user_ns);
+
+	tracer = ptrace_parent(task);
+	tinfo.tracer_id = tracer ? task_pid_nr_ns(tracer, pidns) : 0;
+
+	tinfo.tgid = task_tgid_nr_ns(task, pidns);
+	tinfo.ngid = task_numa_group_id(task);
+
+	task_lock(task);
+	strncpy(tinfo.comm, task->comm, TASKINFO_COMM_LEN);
+	tinfo.umask = task->fs ? task->fs->umask : -ENOENT;
+	task_unlock(task);
+
+	rcu_read_unlock();
+
+	tinfo.state = __get_task_state(task); /* currently the same */
+	/* note: __get_task_state is task_state_index in newer kernel */
+	tinfo.pid = pid;	/* is needed? */
+
+	if (lock_task_sighand(task, &flags)) {
+		u64 utime = 0, stime = 0;
+
+		tinfo.num_threads = get_nr_threads(task);
+		tinfo.ppid = task_tgid_nr_ns(task->real_parent, pidns);
+		tinfo.cutime = nsec_to_clock_t(task->signal->cutime);
+		tinfo.cstime = nsec_to_clock_t(task->signal->cstime);
+
+		if (tinfo.pid == tinfo.tgid)
+			thread_group_cputime_adjusted(task, &utime, &stime);
+		else
+			task_cputime_adjusted(task, &utime, &stime);
+
+		tinfo.utime = nsec_to_clock_t(utime);
+		tinfo.stime = nsec_to_clock_t(stime);
+		unlock_task_sighand(task, &flags);
+	}
+
+	return copy_to_user(buffer, &tinfo, sizeof(tinfo));
+}
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index b5189762d275..8b6ab507627d 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -259,3 +259,9 @@ cond_syscall(sys_membarrier);
 cond_syscall(sys_pkey_mprotect);
 cond_syscall(sys_pkey_alloc);
 cond_syscall(sys_pkey_free);
+
+cond_syscall(sys_pidfdopen);
 cond_syscall(sys_map_readlink);
+cond_syscall(sys_pidfdinfo);
+cond_syscall(sys_fdmap);
+cond_syscall(sys_pidmap);
diff --git a/tools/testing/selftests/Makefile b/tools/testing/selftests/Makefile
index 3c9c0bbe7dbb..3bf00050912c 100644
--- a/tools/testing/selftests/Makefile
+++ b/tools/testing/selftests/Makefile
@@ -6,6 +6,7 @@ TARGETS += cpufreq
 TARGETS += cpu-hotplug
 TARGETS += efivarfs
 TARGETS += exec
+TARGETS += fdmap
 TARGETS += firmware
 TARGETS += ftrace
 TARGETS += futex
@@ -21,6 +22,7 @@ TARGETS += mount
 TARGETS += mqueue
 TARGETS += net
 TARGETS += nsfs
+TARGETS += pidmap
 TARGETS += powerpc
 TARGETS += pstore
 TARGETS += ptrace
diff --git a/tools/testing/selftests/fdmap/.gitignore b/tools/testing/selftests/fdmap/.gitignore
new file mode 100644
index 000000000000..9a9bfdac1cc0
--- /dev/null
+++ b/tools/testing/selftests/fdmap/.gitignore
@@ -0,0 +1 @@
+fdmap_test
diff --git a/tools/testing/selftests/fdmap/Makefile b/tools/testing/selftests/fdmap/Makefile
new file mode 100644
index 000000000000..bf9f051f4b63
--- /dev/null
+++ b/tools/testing/selftests/fdmap/Makefile
@@ -0,0 +1,7 @@
+TEST_GEN_PROGS := fdmap_test
+CFLAGS += -Wall
+
+include ../lib.mk
+
+$(TEST_GEN_PROGS): fdmap_test.c fdmap.c fdmap.h ../kselftest_harness.h
+	$(CC) $(CFLAGS) $(LDFLAGS) $< fdmap.c -o $@
diff --git a/tools/testing/selftests/fdmap/fdmap.c b/tools/testing/selftests/fdmap/fdmap.c
new file mode 100644
index 000000000000..feb3ed1659cd
--- /dev/null
+++ b/tools/testing/selftests/fdmap/fdmap.c
@@ -0,0 +1,102 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include "fdmap.h"
+
+#define	BUF_SIZE	1024
+
+long fdmap(pid_t pid, int *fds, size_t count, int start_fd, int flags)
+{
+	long ret = syscall(336, pid, fds, count, start_fd, flags);
+	return ret != -1 ? ret : -errno;
+}
+
+int fdmap_full(pid_t pid, int **fds, size_t *n)
+{
+	int buf[BUF_SIZE], start_fd = 0;
+	long ret;
+
+	*n = 0;
+	*fds = NULL;
+	for (;;) {
+		int *new_buff;
+
+		ret = fdmap(pid, buf, BUF_SIZE, start_fd, 0);
+		if (ret < 0)
+			break;
+		if (!ret)
+			return 0;
+
+		new_buff = realloc(*fds, (*n + ret) * sizeof(int));
+		if (!new_buff) {
+			ret = -errno;
+			break;
+		}
+		*fds = new_buff;
+		memcpy(*fds + *n, buf, ret * sizeof(int));
+		*n += ret;
+		start_fd = (*fds)[*n - 1] + 1;
+	}
+	free(*fds);
+	*fds = NULL;
+	return -ret;
+}
+
+int fdmap_proc(pid_t pid, int **fds, size_t *n)
+{
+	char fds_path[20];
+	int dir_fd = 0;
+	struct dirent *fd_link;
+	DIR *fds_dir;
+
+	*fds = NULL;
+	*n = 0;
+	if (!pid)
+		strcpy(fds_path, "/proc/self/fd");
+	else
+		sprintf(fds_path, "/proc/%d/fd", pid);
+
+	fds_dir = opendir(fds_path);
+	if (!fds_dir)
+		return errno == ENOENT ? ESRCH : errno;
+	if (!pid)
+		dir_fd = dirfd(fds_dir);
+
+	while ((fd_link = readdir(fds_dir))) {
+		if (fd_link->d_name[0] < '0'
+		    || fd_link->d_name[0] > '9')
+			continue;
+		if (*n % BUF_SIZE == 0) {
+			int *new_buff;
+
+			new_buff = realloc(*fds, (*n + BUF_SIZE) * sizeof(int));
+			if (!new_buff) {
+				int ret = errno;
+
+				free(*fds);
+				*fds = NULL;
+				return ret;
+			}
+			*fds = new_buff;
+		}
+		(*fds)[*n] = atoi(fd_link->d_name);
+		*n += 1;
+	}
+	closedir(fds_dir);
+
+	if (!pid) {
+		size_t i;
+
+		for (i = 0; i < *n; i++)
+			if ((*fds)[i] == dir_fd)
+				break;
+		i++;
+		memmove(*fds + i - 1, *fds + i, (*n - i) * sizeof(int));
+		(*n)--;
+	}
+	return 0;
+}
diff --git a/tools/testing/selftests/fdmap/fdmap.h b/tools/testing/selftests/fdmap/fdmap.h
new file mode 100644
index 000000000000..c501111b2bbd
--- /dev/null
+++ b/tools/testing/selftests/fdmap/fdmap.h
@@ -0,0 +1,12 @@
+#ifndef FDMAP_H
+#define FDMAP_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+
+long fdmap(pid_t pid, int *fds, size_t count, int start_fd, int flags);
+int fdmap_full(pid_t pid, int **fds, size_t *n);
+int fdmap_proc(pid_t pid, int **fds, size_t *n);
+
+#endif
diff --git a/tools/testing/selftests/fdmap/fdmap_test.c b/tools/testing/selftests/fdmap/fdmap_test.c
new file mode 100644
index 000000000000..95fc8e0e3ace
--- /dev/null
+++ b/tools/testing/selftests/fdmap/fdmap_test.c
@@ -0,0 +1,153 @@
+#include <errno.h>
+#include <syscall.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <limits.h>
+#include "../kselftest_harness.h"
+#include "fdmap.h"
+
+TEST(efault) {
+	int ret;
+
+	ret = syscall(336, 0, NULL, 20 * sizeof(int), 0, 0);
+	ASSERT_EQ(-1, ret);
+	ASSERT_EQ(EFAULT, errno);
+}
+
+TEST(big_start_fd) {
+	int fds[1];
+	int ret;
+
+	ret = syscall(336, 0, fds, sizeof(int), INT_MAX, 0);
+	ASSERT_EQ(0, ret);
+}
+
+TEST(einval) {
+	int ret;
+
+	ret = syscall(336, 0, NULL, 0, -1, 0);
+	ASSERT_EQ(-1, ret);
+	ASSERT_EQ(EINVAL, errno);
+
+	ret = syscall(336, 0, NULL, 0, 0, 1);
+	ASSERT_EQ(-1, ret);
+	ASSERT_EQ(EINVAL, errno);
+}
+
+TEST(esrch) {
+	int fds[1], ret;
+	pid_t pid;
+
+	pid = fork();
+	ASSERT_NE(-1, pid);
+	if (!pid)
+		exit(0);
+	waitpid(pid, NULL, 0);
+
+	ret = syscall(336, pid, fds, sizeof(int), 0, 0);
+	ASSERT_EQ(-1, ret);
+	ASSERT_EQ(ESRCH, errno);
+}
+
+TEST(simple) {
+	int *fds1, *fds2;
+	size_t size1, size2, i;
+	int ret1, ret2;
+
+	ret1 = fdmap_full(0, &fds1, &size1);
+	ret2 = fdmap_proc(0, &fds2, &size2);
+	ASSERT_EQ(ret2, ret1);
+	ASSERT_EQ(size2, size1);
+	for (i = 0; i < size1; i++)
+		ASSERT_EQ(fds2[i], fds1[i]);
+	free(fds1);
+	free(fds2);
+}
+
+TEST(init) {
+	int *fds1, *fds2;
+	size_t size1, size2, i;
+	int ret1, ret2;
+
+	ret1 = fdmap_full(1, &fds1, &size1);
+	ret2 = fdmap_proc(1, &fds2, &size2);
+	ASSERT_EQ(ret2, ret1);
+	ASSERT_EQ(size2, size1);
+	for (i = 0; i < size1; i++)
+		ASSERT_EQ(fds2[i], fds1[i]);
+	free(fds1);
+	free(fds2);
+}
+
+TEST(zero) {
+	int *fds, i;
+	size_t size;
+	int ret;
+
+	ret = fdmap_proc(0, &fds, &size);
+	ASSERT_EQ(0, ret);
+	for (i = 0; i < size; i++)
+		close(fds[i]);
+	free(fds);
+	fds = NULL;
+
+	ret = fdmap_full(0, &fds, &size);
+	ASSERT_EQ(0, ret);
+	ASSERT_EQ(0, size);
+}
+
+TEST(more_fds) {
+	int *fds1, *fds2, ret1, ret2;
+	size_t size1, size2, i;
+
+	struct rlimit rlim = {
+		.rlim_cur = 600000,
+		.rlim_max = 600000
+	};
+	ASSERT_EQ(0, setrlimit(RLIMIT_NOFILE, &rlim));
+	for (int i = 0; i < 500000; i++)
+		dup(0);
+
+	ret1 = fdmap_full(0, &fds1, &size1);
+	ret2 = fdmap_proc(0, &fds2, &size2);
+	ASSERT_EQ(ret2, ret1);
+	ASSERT_EQ(size2, size1);
+	for (i = 0; i < size1; i++)
+		ASSERT_EQ(fds2[i], fds1[i]);
+	free(fds1);
+	free(fds2);
+}
+
+TEST(child) {
+	int pipefd[2];
+	int *fds1, *fds2, ret1, ret2, i;
+	size_t size1, size2;
+	char byte = 0;
+	pid_t pid;
+
+	ASSERT_NE(-1, pipe(pipefd));
+	pid = fork();
+	ASSERT_NE(-1, pid);
+	if (!pid) {
+		read(pipefd[0], &byte, 1);
+		close(pipefd[0]);
+		close(pipefd[1]);
+		exit(0);
+	}
+
+	ret1 = fdmap_full(0, &fds1, &size1);
+	ret2 = fdmap_proc(0, &fds2, &size2);
+	ASSERT_EQ(ret2, ret1);
+	ASSERT_EQ(size2, size1);
+	for (i = 0; i < size1; i++)
+		ASSERT_EQ(fds2[i], fds1[i]);
+	free(fds1);
+	free(fds2);
+
+	write(pipefd[1], &byte, 1);
+	close(pipefd[0]);
+	close(pipefd[1]);
+	waitpid(pid, NULL, 0);
+}
+
+TEST_HARNESS_MAIN
diff --git a/tools/testing/selftests/pidfdinfo/.gitignore b/tools/testing/selftests/pidfdinfo/.gitignore
new file mode 100644
index 000000000000..6d4a8d43b7f1
--- /dev/null
+++ b/tools/testing/selftests/pidfdinfo/.gitignore
@@ -0,0 +1 @@
+pidfdinfo
diff --git a/tools/testing/selftests/pidfdinfo/Makefile b/tools/testing/selftests/pidfdinfo/Makefile
new file mode 100644
index 000000000000..debbf824cc0a
--- /dev/null
+++ b/tools/testing/selftests/pidfdinfo/Makefile
@@ -0,0 +1,5 @@
+CFLAGS = -Wall
+
+TEST_GEN_PROGS := pidfdinfo
+
+include ../lib.mk
diff --git a/tools/testing/selftests/pidfdinfo/pidfdinfo.c b/tools/testing/selftests/pidfdinfo/pidfdinfo.c
new file mode 100644
index 000000000000..9f622780cd10
--- /dev/null
+++ b/tools/testing/selftests/pidfdinfo/pidfdinfo.c
@@ -0,0 +1,143 @@
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <assert.h>
+#include "taskinfo.h"
+#include "../kselftest_harness.h"
+
+#define __ASSERT__(p)	\
+	if ((p)) {	\
+		printf("Assert:line %d:\n\t%s\n", __LINE__, #p); \
+		return 1; \
+	}
+
+#define SIZE 4096
+
+static inline long pidfdinfo(pid_t pid, int fd,
+			     struct fdinfo *buffer, unsigned int size)
+{
+	long ret = syscall(335, pid, fd, buffer, size);
+	return ret != -1 ? ret : -errno;
+}
+
+static int pidfdinfo_check_proc(pid_t pid, int fd)
+{
+	char *proc_fd_path, *proc_fdinfo_path, *real_path;
+	FILE *proc_fdinfo;
+	int flags, filen, pathlen;
+	struct fdinfo *fdinfo;
+	long long pos;
+
+	fdinfo = calloc(1, SIZE);
+	assert(fdinfo);
+	filen = pidfdinfo(pid, fd, fdinfo, SIZE);
+	if (filen <= 0)
+		return 1;
+
+	proc_fdinfo_path = calloc(1, SIZE);
+	assert(proc_fdinfo_path);
+	snprintf(proc_fdinfo_path, SIZE, "/proc/%d/fdinfo/%d", pid, fd);
+	proc_fdinfo = fopen(proc_fdinfo_path, "r");
+	assert(proc_fdinfo);
+	fscanf(proc_fdinfo, "pos:\t%lli\nflags:\t0%o\n",
+			&pos, &flags);
+	fclose(proc_fdinfo);
+	free(proc_fdinfo_path);
+	assert(pos == fdinfo->pos);
+	assert(((fdinfo->flags & FDINFO_RDONLY) != 0)
+			== ((flags & O_ACCMODE) == O_RDONLY));
+	assert(((fdinfo->flags & FDINFO_WRONLY) != 0)
+			== ((flags & O_ACCMODE) == O_WRONLY));
+	assert(((fdinfo->flags & FDINFO_RDWR) != 0)
+			== ((flags & O_ACCMODE) == O_RDWR));
+	assert(((fdinfo->flags & FDINFO_CREAT) != 0)
+			== ((flags & O_CREAT) != 0));
+
+	real_path = calloc(1, SIZE);
+	assert(real_path);
+	proc_fd_path = calloc(1, SIZE);
+	assert(proc_fd_path);
+	snprintf(proc_fd_path, SIZE, "/proc/%d/fd/%d", pid, fd);
+
+	pathlen = readlink(proc_fd_path, real_path, SIZE);
+	free(proc_fd_path);
+	assert(pathlen != -1);
+	real_path[pathlen] = '\0';
+	assert(!memcmp(real_path,
+			fdinfo->path,
+			filen - offsetof(struct fdinfo, path) - 1));
+
+	free(fdinfo);
+	free(real_path);
+	return 0;
+}
+
+TEST(self_stdout)
+{
+	ASSERT_EQ(0, pidfdinfo_check_proc(getpid(), 1));
+}
+
+TEST(parent_stdin)
+{
+	ASSERT_EQ(0, pidfdinfo_check_proc(getppid(), 0));
+}
+
+TEST(einval)
+{
+	ASSERT_EQ(-EINVAL, pidfdinfo(1, -1, NULL, 1));
+	ASSERT_EQ(-EINVAL, pidfdinfo(-1, 1, NULL, 1));
+}
+
+TEST(efault)
+{
+	ASSERT_EQ(-EFAULT, pidfdinfo(getpid(), 1, NULL, SIZE));
+}
+
+TEST(eacces)
+{
+	if (getuid())
+		ASSERT_EQ(-EACCES, pidfdinfo(1, 1, NULL, 1));
+}
+
+TEST(ebadf)
+{
+	int fd;
+
+	fd = dup(1);
+	ASSERT_NE(-1, fd);
+	close(fd);
+	ASSERT_EQ(-EBADF, pidfdinfo(getpid(), fd, NULL, 1));
+}
+
+TEST(esrch)
+{
+	pid_t pid;
+
+	pid = fork();
+	ASSERT_NE(-1, pid);
+	if (!pid)
+		exit(0);
+	waitpid(pid, NULL, 0);
+	ASSERT_EQ(-ESRCH, pidfdinfo(pid, 1, NULL, 1));
+}
+
+TEST(page_edge)
+{
+	void *page;
+	struct fdinfo *fi;
+	unsigned int offset = offsetof(struct fdinfo, path);
+
+	page = mmap(NULL, SIZE * 2, PROT_WRITE,
+			MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
+	ASSERT_NE(MAP_FAILED, page);
+	ASSERT_NE(-1, mprotect(page + SIZE, SIZE, PROT_NONE));
+
+	fi = page + SIZE - offset;
+	ASSERT_EQ(offset, pidfdinfo(getpid(), 1, fi, offset));
+	munmap(page, SIZE * 2);
+}
+
+TEST_HARNESS_MAIN
diff --git a/tools/testing/selftests/pidfdinfo/taskinfo.h b/tools/testing/selftests/pidfdinfo/taskinfo.h
new file mode 120000
index 000000000000..0eb86eca0aaa
--- /dev/null
+++ b/tools/testing/selftests/pidfdinfo/taskinfo.h
@@ -0,0 +1 @@
+../../../../include/uapi/linux/taskinfo.h
\ No newline at end of file
diff --git a/tools/testing/selftests/pidmap/.gitignore b/tools/testing/selftests/pidmap/.gitignore
new file mode 100644
index 000000000000..a762199f2637
--- /dev/null
+++ b/tools/testing/selftests/pidmap/.gitignore
@@ -0,0 +1 @@
+pidmap
diff --git a/tools/testing/selftests/pidmap/Makefile b/tools/testing/selftests/pidmap/Makefile
new file mode 100644
index 000000000000..3deae4ef7295
--- /dev/null
+++ b/tools/testing/selftests/pidmap/Makefile
@@ -0,0 +1,5 @@
+CFLAGS = -Wall
+
+TEST_GEN_PROGS := pidmap
+
+include ../lib.mk
diff --git a/tools/testing/selftests/pidmap/pidmap.c b/tools/testing/selftests/pidmap/pidmap.c
new file mode 100644
index 000000000000..ec71e1ad45ef
--- /dev/null
+++ b/tools/testing/selftests/pidmap/pidmap.c
@@ -0,0 +1,291 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <sched.h>
+#include <dirent.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <signal.h>
+#include <assert.h>
+#include "taskinfo.h"
+#include "../kselftest_harness.h"
+
+#define SIZE 512
+
+static inline long pidmap(pid_t pid, int *pids, unsigned int count,
+			  unsigned int start_pid, int flags)
+{
+	long ret = syscall(337, pid, pids, count, start_pid, flags);
+	return ret != -1 ? ret : -errno;
+}
+
+static int compare(const void *a, const void *b)
+{
+	return *((int *)a) > *((int *)b);
+}
+
+int pidmap_full(int **pid, unsigned int *res_count)
+{
+	int n;
+	int start_pid = 1;
+	*pid = (int *)malloc(SIZE * sizeof(int));
+	*res_count = 0;
+
+	while ((n = pidmap(0, *pid + *res_count, SIZE, start_pid,
+			   PIDMAP_TASKS)) > 0) {
+		*res_count += n;
+		*pid = (int *)realloc(*pid, (*res_count + SIZE) * sizeof(int));
+		start_pid = (*pid)[*res_count - 1] + 1;
+	}
+	return n;
+}
+
+int pidmap_proc(int **pid, unsigned int *n)
+{
+	DIR *dir = opendir("/proc");
+	struct dirent *dirs;
+
+	*n = 0;
+	*pid = NULL;
+
+	while ((dirs = readdir(dir))) {
+		char dname[32] = "";
+		DIR *task_dir;
+
+		if (dirs->d_name[0] < '0' || dirs->d_name[0] > '9')
+			continue;
+
+		strcpy(dname, "/proc/");
+		strcat(dname, dirs->d_name);
+		strcat(dname, "/task");
+		task_dir = opendir(dname);
+
+		if (task_dir) {
+			struct dirent *task_dirs;
+
+			while ((task_dirs = readdir(task_dir))) {
+				if (task_dirs->d_name[0] < '0' ||
+						task_dirs->d_name[0] > '9')
+					continue;
+
+				*pid = (int *)realloc(*pid, (*n + 1) *
+								sizeof(int));
+				if (*pid == NULL)
+					return -1;
+				*(*pid + *n) = atoi(task_dirs->d_name);
+				*n += 1;
+			}
+		} else {
+			*pid = (int *)realloc(*pid, (*n + 1) * sizeof(int));
+			if (*pid == NULL)
+				return -1;
+			*(*pid + *n) = atoi(dirs->d_name);
+			*n += 1;
+		}
+		closedir(task_dir);
+	}
+	closedir(dir);
+	return 0;
+}
+
+TEST(bufsize)
+{
+	int pid[SIZE];
+
+	EXPECT_EQ(0, pidmap(0, pid, 0, 1, PIDMAP_TASKS));
+}
+
+TEST(get_pid)
+{
+	int pid;
+	int ret;
+
+	ret = pidmap(0, &pid, 1, getpid(), PIDMAP_TASKS);
+	ASSERT_LE(0, ret);
+	EXPECT_EQ(getpid(), pid);
+}
+
+TEST(bad_start)
+{
+	int pid[SIZE];
+
+	ASSERT_LE(0, pidmap(0, pid, SIZE, -1, PIDMAP_TASKS));
+	ASSERT_LE(0, pidmap(0, pid, SIZE, ~0U, PIDMAP_TASKS));
+	ASSERT_LE(0, pidmap(0, pid, SIZE, 0, PIDMAP_TASKS));
+	EXPECT_EQ(1, pid[0]);
+}
+
+TEST(child_pid)
+{
+	pid_t pid = fork();
+
+	if (pid == 0)
+		pause();
+	else {
+		int ret;
+		int result = 0;
+
+		ret = pidmap(0, &result, 1, pid, PIDMAP_TASKS);
+		EXPECT_LE(0, ret);
+		EXPECT_EQ(pid, result);
+		kill(pid, SIGTERM);
+	}
+}
+
+TEST(pidmap_children_flag)
+{
+	int real_pids[SIZE], pids[SIZE];
+	int i;
+
+	for (i = 0; i < SIZE; i++) {
+		pid_t pid = fork();
+		if (!pid) {
+			pause();
+			exit(0);
+		} else if (pid < 0) {
+			perror("fork");
+			exit(1);
+		}
+		real_pids[i] = pid;
+	}
+
+	ASSERT_EQ(SIZE, pidmap(0, pids, SIZE, 0, PIDMAP_CHILDREN));
+	for (i = 0; i < SIZE; i++) {
+		ASSERT_EQ(real_pids[i], pids[i]);
+		kill(real_pids[i], SIGKILL);
+	}
+}
+
+int write_pidmax(int new_pidmax)
+{
+	char old_pidmax[32];
+	char new[32];
+	int fd = open("/proc/sys/kernel/pid_max", O_RDWR);
+
+	if (read(fd, old_pidmax, 32) <= 0)
+		printf("Read failed\n");
+	lseek(fd, 0, 0);
+	snprintf(new, sizeof(new), "%d", new_pidmax);
+	if (write(fd, new, strlen(new)) <= 0)
+		printf("Write failed\n");
+	close(fd);
+	return atoi(old_pidmax);
+}
+
+void do_forks(unsigned int n)
+{
+	while (n--) {
+		pid_t pid = fork();
+
+		if (pid == 0)
+			exit(0);
+		waitpid(pid, NULL, 0);
+	}
+}
+
+TEST(pid_max)
+{
+	int *pid;
+	unsigned int n;
+	int ret, p;
+	int old_pidmax;
+
+	old_pidmax = write_pidmax(50000);
+
+	do_forks(40000);
+
+	p = fork();
+
+	if (p == 0)
+		pause();
+
+	ret = pidmap_full(&pid, &n);
+	kill(p, SIGKILL);
+
+	EXPECT_LE(0, ret);
+	EXPECT_LE(1, n);
+	if (ret < 0 || n <= 0)
+		goto exit;
+	EXPECT_EQ(p, pid[n - 1]);
+exit:
+	write_pidmax(old_pidmax);
+}
+
+void sigquit_h(int sig)
+{
+	assert(sig == SIGQUIT);
+	if (getgid() != getpid())
+		exit(0);
+}
+
+TEST(compare_proc)
+{
+	pid_t pid;
+
+	if (unshare(CLONE_NEWNS | CLONE_NEWPID) == -1)
+		return;
+
+	pid = fork();
+
+	if (pid == 0) {
+		pid_t p;
+		int i = 0;
+
+		signal(SIGQUIT, sigquit_h);
+
+		mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL);
+		mount("none", "/proc", NULL, MS_REC | MS_PRIVATE, NULL);
+		mount("proc", "/proc", "proc",
+			MS_NOSUID | MS_NODEV | MS_NOEXEC, NULL);
+
+		while (i < 150) {
+			i++;
+
+			p = fork();
+
+			if (p == -1) {
+				umount("/proc");
+				return;
+			}
+			if (p == 0) {
+				pause();
+				return;
+			}
+		}
+
+		int *pids, *pids_proc;
+		unsigned int n = 0;
+		unsigned int n_proc = 0;
+		int ret, ret_proc;
+
+		ret = pidmap_full(&pids, &n);
+
+		ret_proc = pidmap_proc(&pids_proc, &n_proc);
+		qsort(pids_proc, n_proc, sizeof(int), compare);
+
+		EXPECT_LE(0, ret);
+		if (ret < 0 || ret_proc < 0)
+			goto exit;
+
+		EXPECT_EQ(n_proc, n);
+		if (n != n_proc)
+			goto exit;
+
+		for (int i = 0; i < n; i++) {
+			EXPECT_EQ(pids_proc[i], pids[i]);
+			if (pids_proc[i] != pids[i])
+				break;
+		}
+exit:
+		free(pids_proc);
+		free(pids);
+		umount("/proc");
+		kill(-getpid(), SIGQUIT);
+	}
+	wait(NULL);
+}
+
+TEST_HARNESS_MAIN
diff --git a/tools/testing/selftests/pidmap/taskinfo.h b/tools/testing/selftests/pidmap/taskinfo.h
new file mode 120000
index 000000000000..0eb86eca0aaa
--- /dev/null
+++ b/tools/testing/selftests/pidmap/taskinfo.h
@@ -0,0 +1 @@
+../../../../include/uapi/linux/taskinfo.h
\ No newline at end of file
