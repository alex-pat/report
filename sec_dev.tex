\pagebreak
\section{РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ}
\label{sec:dev}

В данном разделе рассмотрим основные детали реализации системных вызовов и
пользовательских программ. Ввиду того, что одним важнейшими аспектами разработки
ядра является стабильность, этим вещам необходимо уделить особое внимание.
Однако, перед этим важно описать общие аспекты реализации поставленных задач при
добавлении системных вызовов.

Ранее в Linux все функции-обработчики системных вызовов традиционно имели
название вида \texttt{sys\_*}, например, вызов \texttt{read()} имел следующее
оперделение:
\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage ssize_t sys_read(unsigned int fd, char __user * buf, size_t count)
\end{lstlisting}
\medskip

Тег \texttt{asmlinkage} сообщает компилятору, что функция не должна брать свои
аргументы из регистров, а должна использовать для этого стек. Все системные
вызовы отмечены тегом \texttt{asmlinkage}, так как долгое время вызов
обработчиков из таблицы \texttt{sys\_call\_table} осуществлялся напрямую из кода
на ассемблере.

Однако, в 2009-м году способ объявления обработчика изменился, и начиная с
версии 2.6.29 для этих целей используется набор из нескольних макросов
\texttt{SYSCALL\_DEFINE*}, из-за чего реализация того же вызова \texttt{read()}
сейчас выглядит так:
\medskip
\begin{lstlisting}[style=cstyle]
SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
\end{lstlisting}
\medskip

Макрос \texttt{SYSCALL\_DEFINE3()} объявляет реализацию системного вызова
\texttt{read()} с тремя аргументами. При этом используется достаточно необычное
определение аргументов. Имена аргументов и их типы разделяются таким образом для
того, чтобы препроцессор Си мог осуществлять сопоставление аргументов по
бинарному интерфейсу системных вызовов с тем, что ожидает нормальная функция на
Си. В архитектуре x86\_64, после нескольких раскрытий макросов, строка
\texttt{SYSCALL\_DEFINE3()} превращается в следующее:
\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_read(int fd, char __user *buf, size_t
count) __attribute__((alias(__stringify(SyS_read))));
asmlinkage long SyS_read(long fd, long buf, long count)
{
	long ret = SYSC_read((int) fd, (char __user *) buf, (size_t) count);
	return ret;
}
static inline SYSC_read(int fd, char __user *buf, size_t count)
\end{lstlisting}
\medskip

Как видно, описываются две разные функции и один псевдоним функции.
\texttt{SyS\_read()} объявляется с атрибутом asmlinkage и с теми же аргументами,
но объявленными c типом \texttt{long}, который всегда соответствует размеру
регистра~--- в том виде, как непосредственно передаются аргументы из
пользовательского пространства. Эта функция приводит аргументы в ожидаемые типы,
а после вызывает \texttt{SYSC\_read()}, которая является настоящим именем
функции, содержащей код, реализующий системный вызов. При этом, функция
объявлена как \texttt{static} \texttt{inline}, поэтому она будет заменена
непосредственно на \texttt{SyS\_read()}.

Именно указатель на функцию \texttt{SyS\_read()} помещается в соответствующее
место в массиве \texttt{sys\_call\_table}, а вызов непоследственно нужного
обработчика сводится к выбору указателя по индексу:
\medskip
\begin{lstlisting}[style=cstyle]
if (likely ((nr & __SYSCALL_MASK) < NR_syscalls)) {
	nr = array_index_nospec (nr & __SYSCALL_MASK, NR_syscalls);
	regs->ax = sys_call_table[nr](
		regs->di, regs->si, regs->dx,
		regs->r10, regs->r8, regs->r9);
}
\end{lstlisting}
\medskip

Использование \texttt{array\_index\_nospec()} запрещает процессору осуществить
вызов спекулятивно, тем самым блокируя любые попытки вызовов по адресу вне
\texttt{sys\_call\_table}. Такие меры необходимы для обхода аппаратной
уязвимости Spectre. Непосредственно макросы-обертки при объявлении обработчиков
используются для покрытия уязвимости CVE-2009-0029, позволяющей заполнять
регистр с 32-битный аргументом 64-битным значением, что давало возможность
выходить за пределы массивов при адресации. В связи с этим ядро и производит
дополнительное приведение типов в макросах, описанное выше.

При написании любого кода ядра необходимо учитывать факторы окружения. В любое
время каждый из процессоров в системе может быть в различных состояниях:
\begin{itemize}
\item не связан с каким-либо процессом и обрабатывает аппаратное прерывание;
\item обслуживает программные прерывания;
\item исполняет код в пространстве ядра, связанный с процессом, то есть
  исполняется в пользовательском контексте;
\item исполняет код пространства пользователя.
\end{itemize}

Между этими состояниями имеется очередность. Различные контексты пользователя,
как в пространстве ядра, так и в пространстве пользователя, могут вытеснять друг
друга, однако с прерываниями имеется строгая иерархия. В то время как
исполняется обработчик программного прерывания, ни один другой такой обработчик
этого же типа не будет его вытеснять, а аппаратное прерывание вытеснить может.
Существует несколько способов, которыми пользовательский контекст может
блокировать прерывания, что будет описано ниже. Поэтому стоит учитывать данные
факторы. Кроме того, существует несколько особенностей в работе кода ядра:
\begin{itemize}
\item нет защиты памяти. Если повредится память, как в контексте пользователя,
  так и в контексте прерывания, вся машина может выйдет из строя;
\item нельзя использовать операции с плавающей запятой или MMX. Контекст
  сопроцессора для операций с плавающей точкой не сохраняется из-за больших
  временных затрат на такие действия. Существует только несколько исключений в
  коде ядра, к которых ввиду слишком долгого исполнения криптографических
  алгоритмов используются векторные вычисления и сохраняется весь контекстр
  исполняющего устройсвтва;
\item жесткий предел стека. В зависимости от параметров конфигурации стек ядра
  составляет от трех до шести килобайт на большинстве 32-битных и 14 килобайт
  для большинства 64-битных архитектур, и часто используется в том числе
  прерываниями, поэтому не рекомндуется использовать весь стек. Следует избегать
  глубокой рекурсии и больших локальных массивов в стеке, вместо этого следует
  выделять их динамически;
\item в коде ядра нужно избегать использования платформозависимых вещей, и
  оставлять их только там, где это необходимо, так как, например, сборка для
  встроенного устройства должна быть полностью минимизирована. Как правило,
  подобный код должен быть расположен в архитектурнозависимой директории ядра.
\end{itemize}

Важным моментом является порядок вызова спящих и не спящих функций. Нельзя
вызывать какие-либо спящие функции, за исключением случаев, когда:
\begin{itemize}
\item код исполняется в контексте пользователя;
\item в коде нет спинлоков.
\end{itemize}

Следует обратить внимание, что некоторые функции могут спать неявно, например,
функции доступа к пространству пользователя (так как, например, память по
переданному указателю может быть отображена в файл на сетевой файловой системе)
или функции выделения ядерной памяти без флага \texttt{GFP\_ATOMIC}. В качестве
вспомогательного средства в этом вопросе можно использовать опцию компиляции
\texttt{CONFIG\_DEBUG\_ATOMIC\_SLEEP}, и ядро предупредит в случае нарушения
правил работы с памятью.

% pidmap

Как уже было сказано в разделе \ref{sec:func}, вызов \texttt{sys\_pidmap} может
возвращать в пространство пользователя идентификаторы разных задач в зависимости
от педеданных флагов. В связи с этим логично разделить код вызова не несколько
функций в самом начале по функциональному критерию. Кроме того, так как один из
флагов является опциональным дополнением к некоторым другим, важно отделить
решающие параметры от остальных:
\medskip
\begin{lstlisting}[style=cstyle]
int param = flags & PIDMAP_PARAM;
switch (param) {
case PIDMAP_TASKS:
case PIDMAP_PROC:
	return pidmap_tasks(pids, count, start, flags);
case PIDMAP_CHILDREN:
	return pidmap_children(pid, pids, count, start);
case PIDMAP_THREADS:
	return pidmap_threads(pid, pids, count, start);
}
\end{lstlisting}
\medskip

В данном случае \texttt{PIDMAP\_PARAM}~--- маска, оставляющая только те биты, в
одном из которых дожен находиться флаг, описывающий необходимое поведение. У
добавленых функций следующие назначения:
\begin{itemize}
\item \texttt{pidmap\_tasks}~--- предоставление всех процессов или потоков в системе;
\item \texttt{pidmap\_children}~--- предоставление списка детей опреленного процесса;
\item \texttt{pidmap\_threads}~--- предоставление списка потоков процесса.
\end{itemize}

Так как флаги \texttt{PIDMAP\_TASKS} и \texttt{PIDMAP\_PROC} дают общесистемную
инофрмацию, параметр \texttt{pid} системного вызова игнорируется. Кроме того,
оба флага используют одну функцию ввиду того, что ее реализации используется
проход по массиву выделенных идентификаторов и уже в процессе прохода
определяется, нужен ли пользователю идентификатор.

В функции \texttt{pidmap\_tasks} существует возможность оптимизации процесса
получения идентификаторов. Дело в том, что ввиду поддержки ядром UNIX
Timesharing System процессы существуют в пределах своего пространства имен.
Пространство имен идентификаторов процессов описывается структурой
\texttt{pid\_namespace}:
\medskip
\begin{lstlisting}[style=cstyle]
struct pid_namespace {
	struct kref kref;
	struct pidmap pidmap[PIDMAP_ENTRIES];
	struct rcu_head rcu;
	int last_pid;
	/* ... */
}
\end{lstlisting}
\medskip

Данная структура управляет обстью видимости процессов, процессом выделения
идентификаторов. Как видно, идентификаторы выделяются при момощи массива
структур \texttt{pidmap} в одном из полей структуры пространства имен.
Определение структуры следующее:
\medskip
\begin{lstlisting}[style=cstyle]
struct pidmap {
       atomic_t nr_free;
       void *page;
};
\end{lstlisting}
\medskip

Структура описывает маску выделенных идентификаторов, в ней содержится поле с
числом свободных идентификаторов \texttt{nr\_free}, а также указатель на
страницу с непосредственно битовой маской \texttt{page}. Единичный бит означает,
что идентификатор выделен, нулевой~--- свободен. В массиве \texttt{pidmap}
некоторые элементы могут иметь нулевой указатель на страницу, то есть страница
может быть не выделена для экономии памяти.

Таким образом, поиск идентификаторов заключается в проходе по массику страниц с
битовыми масками, а само значение идентификатора складывается из номера
структуры, номера числа в странице и номера байта в числе. Поиске очередного
бита осуществляется с помощью функции \texttt{\_\_ffs()}, которая на большинстве
архитектур компилируется в машинную инструкцию \texttt{ffs} (find first set), с
помощью которой определяется номер первого ненулевого бита в числе.

Функции \texttt{pidmap\_children} и \texttt{pidmap\_threads} предназначены
соответственно для получения идентификаторов дочерних процессов и потоков
процесса. Обе функции в первую очередь должны получить структуру, описывающую
процесс с переданным в системный вызов идентификатором. Кроме того, хорошим
решением в данном случае является возможность более быстрого и удобного указания
процессом на себя путем передачи идентификатора, равного единице. Часто в
различных источниках процессом с нулевым идентификатором называют само ядро
системы, однако это не так. Технически, задачей с нулевым идентификатором
является так называемая задача \texttt{init\_task}, статически существующая в
ядре и исполнемом файле с секции \texttt{.data}. Эта задача фактически фиктивна
и существует только ради поддержки факта того, что у каждого процесса должен
быть существующий родитель, чтобы все процессы таким образом образовывали
дерево, и фиктивная начальная задача явлется в таком дереве корнем.

Логичным решением ввиду аналогичности процесса получения исследуемого процесса
является выделение этого действия в отдельную функцию \texttt{pidmap\_get\_task}
для уменьшения повторяемости кода и поддерживаемости. Определение функции
следующее:
\medskip
\begin{lstlisting}[style=cstyle]
static struct task_struct *pidmap_get_task(pid_t pid, bool *has_perms);
\end{lstlisting}
\medskip

Получение указателя на структуру, описывающую текущую задачу, осуществляется при
помощи макроса \texttt{current}, результат которого разнится между контексами.
Так как Linux поддерживает пространста имен в соответствии с Unix Timesharing
System, важно получить доступ к пространству идентификаторов процессов
относительно текущего процесса, искать процесс относительно этого пространства
имен, а также проверить наличие прав на доступ к информации для текущего
процесса. Получение текущего пространства осуществляется при помощи функции
\texttt{task\_active\_pid\_ns()} с передачей параметом \texttt{current}.
Получение указателя на структуру задачи по идентификатору и пространству имен
выполняется при помощи вызова функции \texttt{find\_task\_by\_pid\_ns()},
которой передаются указатели на структуру задачи и структуру пространства имен
идентификаторов процессов. Основная часть получения задачи выглядит следующим
образом:
\medskip
\begin{lstlisting}[style=cstyle]
if (pid == 0) {
	*has_perms = true;
	return current;
}

pid_ns = task_active_pid_ns(current);
task = find_task_by_pid_ns(pid, pid_ns);
if (!task)
	return ERR_PTR(-ESRCH);
*has_perms = pidmap_perm(pid_ns);
if (!*has_perms && !ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
	return ERR_PTR(-EACCES);
\end{lstlisting}
\medskip

Функция \texttt{pidmap\_perm} предназначена для проверки у пространства имен
наличия параметра \texttt{HIDEPID\_INVISIBLE}. Данный параметр предназначен для
сокрытия от задачи всех других процессов, другими словами, в директории
\texttt{/proc/} процесс обнаружит из директорий с информацией о процессах
только свою директорию о себе. Проверка осуществлена в данном виде:
\medskip
\begin{lstlisting}[style=cstyle]
static inline bool pidmap_perm(const struct pid_namespace *pid_ns)
{
	return pid_ns->hide_pid < HIDEPID_INVISIBLE
		|| in_group_p(pid_ns->pid_gid);
}
\end{lstlisting}
\medskip

Функция \texttt{ERR\_PTR()} используется в случаях, когда функция может
возвратить либо указатель, либо ошибку. Для подобного опционального возврата
не используется дополнительных структур или выделений памяти. Вместо этого
используется факт того, что несколько десятков верхних адресов никогда не могут
быть валидными, поэтому их можно использовать в качестве кода ошибки. Упомянутая
функция используется для упаковки ошибки в адрес. Кроме нее, используются такие
фунции как \texttt{IS\_ERR()} для проверки возвращенного функцией указателя на
наличие в нем кода ошибки, \texttt{IS\_ERR()} для получения кода ошибки из
возвращенного указателя и другие. Типичный сценарий использования выглядит
следующим образом:
\medskip
\begin{lstlisting}[style=cstyle]
rcu_read_lock();
task = pidmap_get_task(pid, &has_perms);
if (IS_ERR(task)) {
	/* Returned error */
	rcu_read_unlock();
	return PTR_ERR(task);
}
\end{lstlisting}
\medskip

После получения структуры исследуемого процесса функциям необходимо
проитерироваться по дочерним процессам либо потокам, в зависимости от того,
какая выполняется функция.

Сама по себе задача представлена структурой \texttt{task\_struct}, которая
является одной из самых больших структур ядра. В ней расположена различная
информация для планировщика, состояние, флаги, идентификаторы и различная другая
информация, указатели на структуры, описывающие виртуальную память, файлую
подсистему, а также структуры элементов списков.

Структуры в ядре Linux объединены в списки несколько иным образом по сравнению с
тем, как это делают в программах пространства пользователя. Фактически, списки в
ядре представляют собой кольца. При этом, вместо того, чтобы иметь в специальном
месте указатель на начало списка, каждый элемент является головой списка. Кроме
того, структуры, описывающие элемент списка (содержащие указатели на соседей),
находятся внутри структур, живущих в списках, а не наоборот, когда в структуре
элемента списка был указатель на настоящую структуру, к которой предоставляется
доступ. Эта структура имеет следующий вид:
\medskip
\begin{lstlisting}[style=cstyle]
struct list_head {
	struct list_head *next, *prev;
};
\end{lstlisting}
\medskip

Пара указателей содержат адреса аналогичных структур в объектах-соседях, а
доступ к самим объектам осуществляется при помощи использования нестандартной
возможности времени компиляции \texttt{offsetof}, позволяющей получить смещение
поля в структуре, после чего полученной смещение можно вычесть из виртуального
адреса структуры \texttt{list\_head} для получения адреса содержащей ее
структуры. Естественно, что постоянное ручное использование подобной адресной
арифметики способно вызвать большое количество ошибок, поэтому для списков
существует множество макросов, упрощающих их использование:
\medskip
\begin{lstlisting}[style=cstyle]
#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
#define container_of(ptr, type, member) ({		\
	void *__mptr = (void *)(ptr);			\
	((type *)(__mptr - offsetof(type, member))); })
\end{lstlisting}
\medskip

В итоге, для получения идентификаторов дочерних процессов или потоков необходимо
проитерироваться по соответствующему списку. Когда процесс создает несколько
дочерних процессов, у этих детей есть ссылки на родителя. Для описания этих
отношений в структуре \texttt{task\_struct} имеется несколько полей:
\begin{itemize}
\item \texttt{real\_parent}~--- указывает на структуру процесса, которая создал
  процесс или на структуру процесса \texttt{init}, если родительский процесс
  больше не существует;
\item \texttt{parent}~--- укаазывает на текущий родительский процесс, то есть на
  тот процесс, который должен сигнализироваться при завершении дочернего
  процесса, значение поля обычно совпадает со значением \texttt{real\_parent}.
  Отличия могут быть, например, когда другой процесс осуществляет вызов
  \texttt{ptrace()};
\item \texttt{children}~--- голова списка, содержащего все дочерние процессы;
\item \texttt{sibling}~--- голова списка, в котором расположены процессы с одним
  и тем же родителем.
\end{itemize}

Кроме того, существуют другие отношения между процессами: процесс может быть
лидером группы процессов или сеанса входа в систему, может быть лидером группы
потоков, и он также может заниматься трассировкой других процессов. Иногда ядро
должно иметь возможность получать указатель на \texttt{task\_struct}
соответствующий PID. Это происходит, например, при обслуживании системного
вызова \texttt{kill()}. Когда один процесс шлет сигнал другому процессу, он
вызывает системный вызов \texttt{kill()}, передавая идентификатор в качетсве
параметра. Ядро находит структуру, а затем извлекает указатель на структуру
данных, которая записывает сигналы. Просмотр списка процессов последовательно и
проверка поля \texttt{pid} возможна, но неэффективна. Чтобы ускорить поиск,
существуют четыре таблицы хэшей, по одному для \texttt{pid}, \texttt{tgid},
\texttt{pgrp}, \texttt{session}.

Четыре хэш-таблицы динамически выделяются во время инициализации ядра, а их
адреса хранятся в массиве \texttt{pid\_hash}. Размер одной хеш-таблицы зависит
от объема доступной ОЗУ; например, для систем с 512 МБ ОЗУ каждая хэш-таблица
хранится в четырех страницах и включает 2048 записей.

Для простого и безопасного итерирования по спискам в ядре существует макрос
\texttt{list\_for\_each\_entry}, имеющий следующее определение:
\medskip
\begin{lstlisting}[style=cstyle]
#define list_for_each_entry(pos, head, member)		\
  for (pos = list_first_entry(head, typeof(*pos), member);\
       &pos->member != (head);				\
       pos = list_next_entry(pos, member))
\end{lstlisting}
\medskip

В качестве параметов макросу передается имя указателя-итератора, указатель на
голову списка и имя имя поля в структуре содержащее элементы списка в
итерируемых объектах. Например, при использовании функции
\texttt{pidmap\_children} передаются параметры \texttt{child},
\texttt{\&task->children} и \texttt{sibling}.

При итерировании по спискам в многозадачной системе особенно актуален вопрос
того, как итерироваться безопасно, то есть как сделать список консистентным на
время прохождения, и не создавать проблем производительности. Для этих и других
целей в ядре используется RCU.

RCU представляет собой один из механизмов синхронизации, часто используемого в
ядре Linux. RCU добивается хорошей масштабируемости, разрешая чтения
одновременно
с изменениями. В отличие от обычных способов синхронизации, обеспечивающих
исключение между конкурентными контекстами независимо от того, читают они,
пишут. RCU обеспечивает одновременную работу одного писателя и множества чтецов,
гарантирует, что чтения являются согласованными, поддерживая несколько версий
объектов и гарантируя, что они не удаляются до тех пор, пока не будут завершены
все существующие критические секции читателей. Протокол работы RCU построен
таким образом, что работу чтецами и писателями распределяется так, чтобы сделать
чтения максимально быстрыми. В некоторых случаях со стороны чтецов не требуется
никаких дополнительных действий.

Основная идея RCU состоит в том, чтобы разделить процесс изменения на фазы.
Первая фаза изменяет ссылки на объект в структуре данных, то есть меняет
указатель на новую версию либо удаляет, что возможно делать одновременно с
читателями. Причина, по которой безопасно запускать фазу удаления одновременно с
читателями,~--- это особенности современных процессоров, которые гарантируют,
что читатели видят либо старую, либо новую версию структуры данных, а не
частично обновленный указатель, то есть значение размером с регистр меняется
атомарно. На втором этапе выполняется освобождение объектов, удаленных из
структуры данных во время первой фазы. Поскольку удаление старого объекта может
помешать любым читателям, в данный момент имеющим ссылки на этот объект,
удаление не должно начинаться до тех пор, пока все читатели не перестанут
ссылаться на удаляемые объекты.

Разделение узменения объектов на фазы позволяет писателю немедленно выполнить
этап обновления указателя и отложить этап удаления до тех пор, пока все
читатели, не будут завершены. Следует учитывать только читателей, которые
существовали во время фазы изменения указателей, потому что любой читатель,
запущенный после этого, не сможет получить ссылку на старые структуры.

Таким образом, типичная последовательность изменения структур при RCU выглядит
следующим образом:
\begin{itemize}
\item удалить указатели в структуру, чтобы последующие читатели не могли
  получить ссылку ее;
\item подождать, пока все предыдущие читатели завершат исполнение в критических
  секциях чтения;
\item так как больше не может быть ни одного читателя, который будет ссылаться
  на старую структуру, теперь можно безопасно освободить память.
\end{itemize}

Второй шаг~--- ключевая идея, лежащая в основе отложенного освобождения памяти.
Возможность ждать, пока все читатели будут сделаны, позволяет читателям RCU
использовать гораздо более легкую синхронизацию, а в некоторых случаях работать
вообще без какой-либо синхронизации. Напротив, в более традиционных схемах
читатели должны использовать жесткую блокировку, чтобы предотвратить удаление
ссылки из структуры данных. Это связано с тем, что обновления на основе
блокировок обычно обновляют элементы данных прямо внутри структур, поэтому
должны исключать читателей. Напротив, изменения на основе RCU обычно используют
тот факт, что запись в один указатель является атомарной на современных
процессорах, что позволяет осуществлять атомарную вставку, удаление и замену
элементов в связанной структуре без нарушения чтения. Одновременно читатели
могут получать доступ к старым версиям и могут обойтись без атомарных операций,
барьеров и кэш-промахов, которые так дорого стоят на современных компьютерах,
даже в отсутствие конкуренции за блокировку.

В описанной выше процедуре изменяющий контекст выполняет как этап
удаления, так и узменения, но часто полезно, чтобы совершенно другой поток
выполнял это, например, это имеет место в кэше каталогов в ядре Linux. Даже если
один и тот же поток выполняет как шаг изменения, так и шаг удаления, часто
полезно делать это отдельно от них. Например, читатели RCU и изменяющий контекст
не должны вообще обмениваться данными, но RCU обеспечивает скрытую связь с
некоторыми служебными данными на втором этапе.

Основными функциями, представляющими собой интерфейс работы с RCU в ядре,
являются:
\begin{itemize}
\item \texttt{rcu\_read\_lock()};
\item \texttt{rcu\_read\_unlock()};
\item \texttt{synchronize\_rcu()} и \texttt{call\_rcu ()};
\item \texttt{rcu\_assign\_pointer()};
\item \texttt{rcu\_dereference()}.
\end{itemize}

Кроме вышеперечисленных функций существует и другие, однако остальные могут быть
реализованны при помощи этих пяти. Опишем эти основные функции RCU подробнее.

Функция \texttt{rcu\_read\_lock()} используется читателем для информирования о
том, что он входит в критическую секцию RCU для чтения. Следует учитывать, что
нельзя в критической секции чтения под RCU использовать спящие операции, хотя
при этом ядра, собранные с опцией cборки \texttt{CONFIG}-\texttt{PREEMPT\_RCU} могут вытеснять
критические секции чтения под RCU. Любая структура данных, защищенная RCU и
доступ к которой осуществляется только внутри критической секции чтения,
останется неизменной в течение всего выполнения внутри этой критической секции.
Счетчики ссылок могут использоваться совместно с RCU для поддержки долгосрочных
ссылок на структуры данных.

В свою очередь функция \texttt{rcu\_read\_unlock()} используется читающим
контекстом для информирования о выходе его из критической секции чтения под RCU.
Следует обращать внимание на то, что такие критические секции чтения могут быть
вложенными и перекрывающимися.

Функция \texttt{synchronize\_rcu()} обозначает конец кода изменения и начало
кода удаления. Это проиходит благодаря блокировке изменяющего контекста до тех
пор, пока не будут завершены все ранее существовавшие критические секции чтения
RCU на всех процессорах. Важно, что функция \texttt{synchronize\_rcu()} не будет
обязательно ждать завершения любых последующих критических секций чтения.
Другими словами, функция ожидает завершения только существующих в текущее время
критических секций чтения, не обязательно тех, которые начались после вызова
функции. Естественно, функция не обязательно возвращается сразу же после
завершения последней предварительно существующей критической секции чтения.
Во-первых, вполне могут быть задержки ввиду особенностей работы планировщика. С
другой стороны, многие реализации RCU обрабатывают запросы по несколько сразу,
чтобы повысить эффективность. Поскольку функция должна выяснить, когда читатели
завершились, ее производительность является ключевой частью реализации RCU. Для
того чтобы RCU был полезен во всех ситуациях, кроме ситуаций с особенно большой
интенсивностью чтения, накладные расходы работы \texttt{synchronize\_rcu()}
также должны быть минимальными.

Существуют две основные структуры данных, описывающие информацию о файловой
системе для каждого процесса в системе. Во-первых, структура \texttt{fs\_struct}
содержит указатели на иноды этого процесса и его \texttt{umask}. Во-вторых,
структура \texttt{files\_struct} содержит информацию обо всех файлах, которые
процесс использует в настоящий момент. Каждый файлу соответствует собственный
дескриптор, а \texttt{files\_struct} содержит указатель на структуру
\texttt{fdtable}, которая содержит таблицу с указателями на описывающие файловые
дескрипторы структуры \texttt{file} и битовую маску с информацией о свободных и
выделенных дескрипторах. Поле \texttt{f\_mode} описывает, в каком режиме был
создан файл. Поле \texttt{f\_ops} содержит указатель на структуру~--- таблицу
указателей на функции, реализующие работу с файлом на уровне конкретной файловой
системы. Поле \texttt{f\_inode} указывает на структуру иноды, описывающий файл.
Каждый раз, когда файл открывается, один из свободных указателей на в
\texttt{file} используется для работы с новым дескриптором. Процессы в UNIX
ожидают, что три файловых дескриптора будут открыты при их запуске. Каждый
доступ к файлу использует структуру \texttt{file\_operations} для вызова
функции, реализующей определенное действие на уровне файловой системы.
