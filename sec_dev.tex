\pagebreak
\section{РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ}
\label{sec:dev}

В данном разделе рассмотрим основные детали реализации системных вызовов и
пользовательских программ. Ввиду того, что одним важнейшими аспектами разработки
ядра является стабильность, этим вещам необходимо уделить особое внимание.
Однако, перед этим важно описать общие аспекты реализации поставленных задач при
добавлении системных вызовов.

Ранее в Linux все функции-обработчики системных вызовов традиционно имели
название вида \texttt{sys\_*}, например, вызов \texttt{read()} имел следующее
оперделение:
\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage ssize_t sys_read(unsigned int fd, char __user * buf, size_t count)
\end{lstlisting}
\medskip

Тег \texttt{asmlinkage} сообщает компилятору, что функция не должна брать свои
аргументы из регистров, а должна использовать для этого стек. Все системные
вызовы отмечены тегом \texttt{asmlinkage}, так как долгое время вызов
обработчиков из таблицы \texttt{sys\_call\_table} осуществлялся напрямую из кода
на ассемблере.

Однако, в 2009-м году способ объявления обработчика изменился, и начиная с
версии 2.6.29 для этих целей используется набор из нескольних макросов
\texttt{SYSCALL\_DEFINE*}, из-за чего реализация того же вызова \texttt{read()}
сейчас выглядит так:
\medskip
\begin{lstlisting}[style=cstyle]
SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
\end{lstlisting}
\medskip

Макрос \texttt{SYSCALL\_DEFINE3()} объявляет реализацию системного вызова
\texttt{read()} с тремя аргументами. При этом используется достаточно необычное
определение аргументов. Имена аргументов и их типы разделяются таким образом для
того, чтобы препроцессор Си мог осуществлять сопоставление аргументов по
бинарному интерфейсу системных вызовов с тем, что ожидает нормальная функция на
Си. В архитектуре x86\_64, после нескольких раскрытий макросов, строка
\texttt{SYSCALL\_DEFINE3()} превращается в следующее:
\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_read(int fd, char __user *buf, size_t
count) __attribute__((alias(__stringify(SyS_read))));
asmlinkage long SyS_read(long fd, long buf, long count)
{
	long ret = SYSC_read((int) fd, (char __user *) buf, (size_t) count);
	return ret;
}
static inline SYSC_read(int fd, char __user *buf, size_t count)
\end{lstlisting}
\medskip

Как видно, описываются две разные функции и один псевдоним функции.
\texttt{SyS\_read()} объявляется с атрибутом asmlinkage и с теми же аргументами,
но объявленными c типом \texttt{long}, который всегда соответствует размеру
регистра~--- в том виде, как непосредственно передаются аргументы из
пользовательского пространства. Эта функция приводит аргументы в ожидаемые типы,
а после вызывает \texttt{SYSC\_read()}, которая является настоящим именем
функции, содержащей код, реализующий системный вызов. При этом, функция
объявлена как \texttt{static} \texttt{inline}, поэтому она будет заменена
непосредственно на \texttt{SyS\_read()}.

Именно указатель на функцию \texttt{SyS\_read()} помещается в соответствующее
место в массиве \texttt{sys\_call\_table}, а вызов непоследственно нужного
обработчика сводится к выбору указателя по индексу:
\medskip
\begin{lstlisting}[style=cstyle]
if (likely ((nr & __SYSCALL_MASK) < NR_syscalls)) {
	nr = array_index_nospec (nr & __SYSCALL_MASK, NR_syscalls);
	regs->ax = sys_call_table[nr](
		regs->di, regs->si, regs->dx,
		regs->r10, regs->r8, regs->r9);
}
\end{lstlisting}
\medskip

Использование \texttt{array\_index\_nospec()} запрещает процессору осуществить
вызов спекулятивно, тем самым блокируя любые попытки вызовов по адресу вне
\texttt{sys\_call\_table}. Такие меры необходимы для обхода аппаратной
уязвимости Spectre. Непосредственно макросы-обертки при объявлении обработчиков
используются для покрытия уязвимости CVE-2009-0029, позволяющей заполнять
регистр с 32-битный аргументом 64-битным значением, что давало возможность
выходить за пределы массивов при адресации. В связи с этим ядро и производит
дополнительное приведение типов в макросах, описанное выше.

При написании любого кода ядра необходимо учитывать факторы окружения. В любое
время каждый из процессоров в системе может быть в различных состояниях:
\begin{itemize}
\item не связан с каким-либо процессом и обрабатывает аппаратное прерывание;
\item обслуживает программные прерывания;
\item исполняет код в пространстве ядра, связанный с процессом, то есть
  исполняется в пользовательском контексте;
\item исполняет код пространства пользователя.
\end{itemize}

Между этими состояниями имеется очередность. Различные контексты пользователя,
как в пространстве ядра, так и в пространстве пользователя, могут вытеснять друг
друга, однако с прерываниями имеется строгая иерархия. В то время как
исполняется обработчик программного прерывания, ни один другой такой обработчик
этого же типа не будет его вытеснять, а аппаратное прерывание вытеснить может.
Существует несколько способов, которыми пользовательский контекст может
блокировать прерывания, что будет описано ниже. Поэтому стоит учитывать данные
факторы. Кроме того, существует несколько особенностей в работе кода ядра:
\begin{itemize}
\item нет защиты памяти. Если повредится память, как в контексте пользователя,
  так и в контексте прерывания, вся машина может выйдет из строя;
\item нельзя использовать операции с плавающей запятой или MMX. Контекст
  сопроцессора для операций с плавающей точкой не сохраняется из-за больших
  временных затрат на такие действия. Существует только несколько исключений в
  коде ядра, к которых ввиду слишком долгого исполнения криптографических
  алгоритмов используются векторные вычисления и сохраняется весь контекстр
  исполняющего устройсвтва;
\item жесткий предел стека. В зависимости от параметров конфигурации стек ядра
  составляет от трех до шести килобайт на большинстве 32-битных и 14 килобайт
  для большинства 64-битных архитектур, и часто используется в том числе
  прерываниями, поэтому не рекомндуется использовать весь стек. Следует избегать
  глубокой рекурсии и больших локальных массивов в стеке, вместо этого следует
  выделять их динамически;
\item в коде ядра нужно избегать использования платформозависимых вещей, и
  оставлять их только там, где это необходимо, так как, например, сборка для
  встроенного устройства должна быть полностью минимизирована. Как правило,
  подобный код должен быть расположен в архитектурнозависимой директории ядра.
\end{itemize}

Важным моментом является порядок вызова спящих и не спящих функций. Нельзя
вызывать какие-либо спящие функции, за исключением случаев, когда:
\begin{itemize}
\item код исполняется в контексте пользователя;
\item в коде нет спинлоков.
\end{itemize}

Следует обратить внимание, что некоторые функции могут спать неявно, например,
функции доступа к пространству пользователя (так как, например, память по
переданному указателю может быть отображена в файл на сетевой файловой системе)
или функции выделения ядерной памяти без флага \texttt{GFP\_ATOMIC}. В качестве
вспомогательного средства в этом вопросе можно использовать опцию компиляции
\texttt{CONFIG\_DEBUG\_ATOMIC\_SLEEP}, и ядро предупредит в случае нарушения
правил работы с памятью.

% pidmap

Как уже было сказано в разделе \ref{sec:func}, вызов \texttt{sys\_pidmap} может
возвращать в пространство пользователя идентификаторы разных задач в зависимости
от педеданных флагов. В связи с этим логично разделить код вызова не несколько
функций в самом начале по функциональному критерию. Кроме того, так как один из
флагов является опциональным дополнением к некоторым другим, важно отделить
решающие параметры от остальных:
\medskip
\begin{lstlisting}[style=cstyle]
int param = flags & PIDMAP_PARAM;
switch (param) {
case PIDMAP_TASKS:
case PIDMAP_PROC:
	return pidmap_tasks(pids, count, start, flags);
case PIDMAP_CHILDREN:
	return pidmap_children(pid, pids, count, start);
case PIDMAP_THREADS:
	return pidmap_threads(pid, pids, count, start);
}
\end{lstlisting}
\medskip

В данном случае \texttt{PIDMAP\_PARAM}~--- маска, оставляющая только те биты, в
одном из которых дожен находиться флаг, описывающий необходимое поведение. У
добавленых функций следующие назначения:
\begin{itemize}
\item \texttt{pidmap\_tasks}~--- предоставление всех процессов или потоков в системе;
\item \texttt{pidmap\_children}~--- предоставление списка детей опреленного процесса;
\item \texttt{pidmap\_threads}~--- предоставление списка потоков процесса.
\end{itemize}

Так как флаги \texttt{PIDMAP\_TASKS} и \texttt{PIDMAP\_PROC} дают общесистемную
инофрмацию, параметр \texttt{pid} системного вызова игнорируется. Кроме того,
оба флага используют одну функцию ввиду того, что ее реализации используется
проход по массиву выделенных идентификаторов и уже в процессе прохода
определяется, нужен ли пользователю идентификатор.

В функции \texttt{pidmap\_tasks} существует возможность оптимизации процесса
получения идентификаторов. Дело в том, что ввиду поддержки ядром UNIX
Timesharing System процессы существуют в пределах своего пространства имен.
Пространство имен идентификаторов процессов описывается структурой
\texttt{pid\_namespace}:
\medskip
\begin{lstlisting}[style=cstyle]
struct pid_namespace {
	struct kref kref;
	struct pidmap pidmap[PIDMAP_ENTRIES];
	struct rcu_head rcu;
	int last_pid;
	/* ... */
}
\end{lstlisting}
\medskip

Данная структура управляет обстью видимости процессов, процессом выделения
идентификаторов. Как видно, идентификаторы выделяются при момощи массива
структур \texttt{pidmap} в одном из полей структуры пространства имен.
Определение структуры следующее:
\medskip
\begin{lstlisting}[style=cstyle]
struct pidmap {
       atomic_t nr_free;
       void *page;
};
\end{lstlisting}
\medskip

Структура описывает маску выделенных идентификаторов, в ней содержится поле с
числом свободных идентификаторов \texttt{nr\_free}, а также указатель на
страницу с непосредственно битовой маской \texttt{page}. Единичный бит означает,
что идентификатор выделен, нулевой~--- свободен. В массиве \texttt{pidmap}
некоторые элементы могут иметь нулевой указатель на страницу, то есть страница
может быть не выделена для экономии памяти.

Таким образом, поиск идентификаторов заключается в проходе по массику страниц с
битовыми масками, а само значение идентификатора складывается из номера
структуры, номера числа в странице и номера байта в числе. Поиске очередного
бита осуществляется с помощью функции \texttt{\_\_ffs()}, которая на большинстве
архитектур компилируется в машинную инструкцию \texttt{ffs} (find first set), с
помощью которой определяется номер первого ненулевого бита в числе.

Функции \texttt{pidmap\_children} и \texttt{pidmap\_threads} предназначены
соответственно для получения идентификаторов дочерних процессов и потоков
процесса. Обе функции в первую очередь должны получить структуру, описывающую
процесс с переданным в системный вызов идентификатором. Кроме того, хорошим
решением в данном случае является возможность более быстрого и удобного указания
процессом на себя путем передачи идентификатора, равного единице. Часто в
различных источниках процессом с нулевым идентификатором называют само ядро
системы, однако это не так. Технически, задачей с нулевым идентификатором
является так называемая задача \texttt{init\_task}, статически существующая в
ядре и исполнемом файле с секции \texttt{.data}. Эта задача фактически фиктивна
и существует только ради поддержки факта того, что у каждого процесса должен
быть существующий родитель, чтобы все процессы таким образом образовывали
дерево, и фиктивная начальная задача явлется в таком дереве корнем.

Логичным решением ввиду аналогичности процесса получения исследуемого процесса
является выделение этого действия в отдельную функцию \texttt{pidmap\_get\_task}
для уменьшения повторяемости кода и поддерживаемости. Определение функции
следующее:
\medskip
\begin{lstlisting}[style=cstyle]
static struct task_struct *pidmap_get_task(pid_t pid, bool *has_perms);
\end{lstlisting}
\medskip



% rcu

RCU~--- это механизм синхронизации, который был добавлен в ядро Linux в октябре
2002 года. RCU добивается хорошей масштабируемости, разрешая чтения одновременно
с изменениями. В отличие от обычных способов синхронизации, обеспечивающих
исключение между конкурентными контекстами независимо от того, читают они,
пишут. RCU обеспечивает одновременную работу одного писателя и множества чтецов,
гарантирует, что чтения являются согласованными, поддерживая несколько версий
объектов и гарантируя, что они не удаляются до тех пор, пока не будут завершены
все существующие критические секции читателей. Протокол работы RCU построен
таким образом, что работу чтецами и писателями распределяется так, чтобы сделать
чтения максимально быстрыми. В некоторых случаях со стороны чтецов не требуется
никаких дополнительных действий.

Основная идея RCU состоит в том, чтобы разделить процесс изменения на фазы.
Первая фаза изменяет ссылки на объект в структуре данных, то есть меняет
указатель на новую версию либо удаляет, что возможно делать одновременно с
читателями. Причина, по которой безопасно запускать фазу удаления одновременно с
читателями,~--- это особенности современных процессоров, которые гарантируют,
что читатели видят либо старую, либо новую версию структуры данных, а не
частично обновленный указатель, то есть значение размером с регистр меняется
атомарно. На втором этапе выполняется освобождение объектов, удаленных из
структуры данных во время первой фазы. Поскольку удаление старого объекта может
помешать любым читателям, в данный момент имеющим ссылки на этот объект,
удаление не должно начинаться до тех пор, пока все читатели не перестанут
ссылаться на удаляемые объекты.

Разделение узменения объектов на фазы позволяет писателю немедленно выполнить
этап обновления указателя и отложить этап удаления до тех пор, пока все
читатели, не будут завершены. Следует учитывать только читателей, которые
существовали во время фазы изменения указателей, потому что любой читатель,
запущенный после этого, не сможет получить ссылку на старые структуры.

Таким образом, типичная последовательность изменения структур при RCU выглядит
следующим образом:
\begin{itemize}
\item удалить указатели в структуру, чтобы последующие читатели не могли
  получить ссылку ее;
\item подождать, пока все предыдущие читатели завершат исполнение в критических
  секциях чтения;
\item так как больше не может быть ни одного читателя, который будет ссылаться
  на старую структуру, теперь можно безопасно освободить память.
\end{itemize}

Второй шаг~--- ключевая идея, лежащая в основе отложенного освобождения памяти.
Возможность ждать, пока все читатели будут сделаны, позволяет читателям RCU
использовать гораздо более легкую синхронизацию, а в некоторых случаях работать
вообще без какой-либо синхронизации. Напротив, в более традиционных схемах
читатели должны использовать жесткую блокировку, чтобы предотвратить удаление
ссылки из структуры данных. Это связано с тем, что обновления на основе
блокировок обычно обновляют элементы данных прямо внутри структур, поэтому
должны исключать читателей. Напротив, изменения на основе RCU обычно используют
тот факт, что запись в один указатель является атомарной на современных
процессорах, что позволяет осуществлять атомарную вставку, удаление и замену
элементов в связанной структуре без нарушения чтения. Одновременно читатели
могут получать доступ к старым версиям и могут обойтись без атомарных операций,
барьеров и кэш-промахов, которые так дорого стоят на современных компьютерах,
даже в отсутствие конкуренции за блокировку.

В описанной выше процедуре изменяющий контекст выполняет как этап
удаления, так и узменения, но часто полезно, чтобы совершенно другой поток
выполнял это, например, это имеет место в кэше каталогов в ядре Linux. Даже если
один и тот же поток выполняет как шаг изменения, так и шаг удаления, часто
полезно делать это отдельно от них. Например, читатели RCU и изменяющий контекст
не должны вообще обмениваться данными, но RCU обеспечивает скрытую связь с
некоторыми служебными данными на втором этапе.

Основными функциями, представляющими собой интерфейс работы с RCU в ядре,
являются:
\begin{itemize}
\item \texttt{rcu\_read\_lock()};
\item \texttt{rcu\_read\_unlock()};
\item \texttt{synchronize\_rcu()} и \texttt{call\_rcu ()};
\item \texttt{rcu\_assign\_pointer()};
\item \texttt{rcu\_dereference()}.
\end{itemize}

Кроме вышеперечисленных функций существует и другие, однако остальные могут быть
реализованны при помощи этих пяти. Опишем эти основные функции RCU подробнее.

Функция \texttt{rcu\_read\_lock()} используется читателем для информирования о
том, что он входит в критическую секцию RCU для чтения. Следует учитывать, что
нельзя в критической секции чтения под RCU использовать спящие операции, хотя
при этом ядра, собранные с опцией \texttt{CONFIG\_PREEMPT\_RCU} могут вытеснять
критические секции чтения под RCU. Любая структура данных, защищенная RCU и
доступ к которой осуществляется только внутри критической секции чтения,
останется неизменной в течение всего выполнения внутри этой критической секции.
Счетчики ссылок могут использоваться совместно с RCU для поддержки долгосрочных
ссылок на структуры данных.

В свою очередь функция \texttt{rcu\_read\_unlock()} используется читающим
контекстом для информирования о выходе его из критической секции чтения под RCU.
Следует обращать внимание на то, что такие критические секции чтения могут быть
вложенными и перекрывающимися.

Функция \texttt{synchronize\_rcu()} обозначает конец кода изменения и начало
кода удаления. Это проиходит благодаря блокировке изменяющего контекста до тех
пор, пока не будут завершены все ранее существовавшие критические секции чтения
RCU на всех процессорах. Важно, что \texttt{synchronize\_rcu()} не будет
обязательно ждать завершения любых последующих критических секций чтения.
Другими словами, функция ожидает завершения только существующих в текущее время
критических секций чтения, не обязательно тех, которые начались после вызова
функции. Естественно, функция не обязательно возвращается сразу же после
завершения последней предварительно существующей критической секции чтения.
Во-первых, вполне могут быть задержки ввиду особенностей работы планировщика. С
другой стороны, многие реализации RCU обрабатывают запросы по несколько сразу,
чтобы повысить эффективность. Поскольку функция должна выяснить, когда читатели
завершились, ее производительность является ключевой частью реализации RCU. Для
того чтобы RCU был полезен во всех ситуациях, кроме ситуаций с особенно большой
интенсивностью чтения, накладные расходы работы \texttt{synchronize\_rcu()}
также должны быть минимальными.
