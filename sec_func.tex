\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:func}

В данном разделе описывается функционирование и интерфейс между модулями
разрабатываемой системы. В первую очередь перед этим необходимо выделить и
конкретизировать необходимые для реализации критерии, составляющие
результирующие преимущества системы, а также определить путь решения
поставленных задач. К таким вопросам относятся:

\begin{itemize}
\item формат и состав структур;
\item расположение данных переменной длины;
\item возоможность пользователю определять состав получаемых данных;
\item долговечность формата данных;
\item обход контроля пространством пользователя размера выделяемой памяти.
\end{itemize}

Опишем подробнее каждый из пунктов. Как было определено ранее и как показывает
мировая практика, оптимальным форматом данных является бинарная структура, а не
текстовый поток. Кроме того, для предотвращения получения пользовательской
программой лишних данных и структурирования интерфейса системы, необходимо
логически разделить возможные передаваемые данные на подчасти. Описанные условия
будут описаны далее при описании интерфейса каждого системного вызова.

Часто при разработке интерфейсов встает задача об отпимальном размещении данных,
которые могут занимать либо крайне большие объемы памяти, либо быть вообще
неограниченными по размеру. Примерами таких данных являются имена файлов и
директорий, а также полные пути к файлам. В случае с системами семейства UNIX,
стандарт POSIX ставит достаточно высокие верхние границы размера имен: 255 байт
для имени и 4095 байт для целого пути. Очевидно, что выделять такие объемы
памяти при каждом вызове, даже если результат будет занимать заведомо мало
памяти~--- неоптимальное решение. Общепринятым решением является размещение
данных переменной длины в конце структуры, при этом размер строки указывается
равным нули или единице. Примером таких данных является структура
\texttt{linux\_dirent}, использующаяся в системном вызове \texttt{getdents()}:

\medskip
\begin{lstlisting}[style=cstyle]
struct linux_dirent {
	unsigned long	d_ino;
	unsigned long	d_off;
	unsigned short	d_reclen;
	char		d_name[1];
};
\end{lstlisting}
\medskip

В данном случае поле \texttt{d\_name} используется для хранения имени элемента
директории. Так как в языке Си строки нуль-терминированные, нет необходимости в
дополнительном поле размера имени. Подобный подход с расположением данных
переменного размера в конце структуры используется не только в случае имен и
путей к файлам, но и в случаях отпимизации выделения строк малого размера в
структуре ядра \texttt{dentry} или стандартной библиотеке языка С++. Такое
решение позволяет сэкономить не только выделенную память, но и уменьшить число
кэш-промахов во время работы со структурами, так как непосредственно строка
располагается рядом с описывающей ее структурой.

Часто пользовательской программе для выполнения своей задачи нужна только часть
предоставляемых системой данных. При частых запросах извлечение системой
избыточных данных может занимать значительную часть времени. В таких случаях
создание множества отдельных каналов получения информации для каждого случая
использования является неразумным выбором. Более предпочтительным является
предоставление пространству пользователя возможности указать, какие данные ему
нужны. Одним из способов реализации такого функционала является передача флагов.
Примером использующего флаги для описания перечня необходимых для получения
данных является системный вызов \texttt{statx()}, заполняемая структура которого
в данный момент насчитывает 19 полей. Флаги передаются в виде битовой маски.

При разработке операционной системы и ее компонентов особенно актуален вопрос
поддержки обратной совместимости. При отсутствии совместимости с предыдущими
интерфейсами перестают полноценно функционировать пользовательские программы и
драйвера. И если в случае внутренних бинарных интерфейсов ядра разработчиками
Linux принято решение в пользу переработок интерфейсов для их развития, то
интерфейс между пользовательской программой и ядром обязан быть максимально
стабильным, насколько это возможно. В противном случае операционная система не
имела бы широкой аудитории пользователей. Применяемый по этому вопросу опыт
приводит к такому результату, что программы, собранные даже на ядре версии 0.9
могут успешно  запускаться и работать на современном ядре. Это показывает
важность поддержки обратной совместимости.

В случае разработки нового интерфейса с учетом необходимости поддержки обратной
совместимости важно учитывать возможные изменения в устройстве ядра, из-за
которых перед разработчиком в будущем может встать выбор: перестать поддерживать
интерфейс, нарушив совместимость, или продолжить поддерживать старый интерфейс,
эмулируя поведение старой версии системы. Оба варианта имеют существенные
минусы: при отсутствии поддержки высока вероятность потери системой своей
аудитории, а при принудительной поддержке код системы наполняется большим
количеством избыточного кода. Подобных проблем можно избежать, изначально
проектируя интерфейсы такими, что изменения внутренней архитектуры ядра не будут
влиять на возможность и актуальность их использования. Существует несколько
аспектов проектирования подобных устойчивых интерфейсов:
\begin{itemize}
\item флаги, независимые от внутресистемных;
\item платформонезависимые типы;
\item увеличенные поля.
\end{itemize}

Важной частью разработки интерфейса системных вызовов является проектирование
способа получения данных, размер буфера для которых либо слишком большой для
того, чтобы программа пространства пользователя могла ее разово выделить, либо
слишком большая для того, чтобы ядро могло за один вызов полностью отдать, либо
размер буфера просто неизвестен заранее. При этом важно спроектировать интерфейс
таким образом, чтобы пользовательская программа не могла прямо или косвенно
контролировать размеры выделяемой ядром памяти, чтобы не создавать потенциальные
уязвимости в системе.

Для обеспечения реализации вышеописанных механизмов предпринимается несколько
действий. Во-первых, временные структуры в ядре выделяются фиксированного
размера, что обеспечит отсутствие влияния пользовательских программ на объемы
выделенной памяти. Во-вторых, для обеспечения сбора информации за несколько
вызовов обеспечивается старт сбора с произвольной позиции. Этого можно достичь
двумя способами: сохранением состояния внутри ядра или передачей начальной
позиции пользовательской программой. Первый способ менее предпочтителен ввиду
необходимости дополнительных выделений памяти под хранение состояния между
несколькими вызовами, что тянет за собой массу проблем с тем, когда такую память
освобождать. Решение в пользу ручного освобождения памяти по вызову
пространством пользователя является явной ошибкой ввиду того, что программа
может этот вызов элементарно не сделать, либо не закончить запросы данных по
множеству причин, в результате чего произойдет утечка памяти ядра, что является
серьезной проблемой, кроме того, это противоречит одному из вышеописанных
критериев: независимости выделений памяти ядра от действий пользовательской
программы. Исключением в данном случае можно назвать системный вызов
\texttt{getdents}, позиция чтения для которого хранится в поле \texttt{private}
структры \texttt{file}, однако подобный подход неприменим в рамках решаемой
задачи, так как в подразумевает открытие файла и все сопутствующие выделения.
Выбор в пользу автоматического освобождения памяти (например, по
истечению времени) также является опасным решением ввиду того, что по сути в
таком случае пользовательская программа тоже влияет на объемы выделенной памяти,
хотя и косвенно. Кроме того, автоматическое освобождение памяти требует
значительных затрат времени выполнения. Таким образом, наиболее оптимальным
вариантом передачи данных пространству пользователя является передача позиции,
например, одним из параметров. Позиция может представлять собой порядковый номер
элемента, номер байта, значение последнего прочитанного элемента или первого
элемента для чтения.

При разработке ядра Linux принято разделять и хранить в отдельных местах
заголовочные файлы, используемые только для кода ядра, и файлы, которыми будут
пользоваться разработчики пользовательских программ. Такой подход делает
архитектуру ядра более структурированным и поддерживаемым, что крайне важно при
разработке любой программы, в особенности, и ядра операционной системы.
Заголовочные файлы второго типа (интерфейс пользователя) располагается в
директории \texttt{include/uapi/}. Каждый файл в поддиректориях содержит
определения структур, констант и функций. Содержимое файлов принято не изменять,
а только дополнять, чтобы сохранять обратную совместимость. Поддиректории
предназначены для подсистем звука, видео, интерфейса SCSI, гипервизора XEN,
общесистемных и других заголовков.

Таблицы системных вызовов расположены в соответствующих архитектурам
поддиректориях \texttt{arch/}, например, для архитектуры x86\_64 таблица
расположена в файле \texttt{arch/x86/entry/syscalls/syscall\_64.tbl}.
Файл представляет собой простую текстовую таблицу, в которой содержатся
номера системных вызовов, тип бинарного интерефейса, имя вызова и имя символа
обработчика системного вызова. В процессе сборки ядра таблица парсится
bash-скриптом, который генерирует из нее файл на языке ассемблера. Такой подход
позволяет избежать совершения разработчиками случайных ошибок при дополнении
ассемблерного кода во время разработки новых системных вызовов. Несмотря на то,
что таблица находится не в директории \texttt{include/uapi/}, файл также не
изменяется, а лишь дополняется, так как номера системных вызовов являются
важнейшей частью пользовательского интерфейса ядра.

\subsection{Системный вызов \texttt{sys\_pidmap}}

Системный вызов \texttt{sys\_pidmap} возвращает список идентификаторов
существующих в данный момент в системе процессов и потоков. Иными словами,
заполняет переданный пользовательской программой буфер идентификаторами. Вызов
является расширенной заменой прохождению по директории \texttt{/proc/}. Прототип
обработчика вызова:

\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_pidmap(pid_t pid,
			   int __user *pids,
			   unsigned int pids_count,
			   unsigned int start_pid,
			   int flags);
\end{lstlisting}
\medskip

В зависимости от того, какие данные нужны пространству пользователя, программа
передает одно из следующих значений в параметр \texttt{flags}:

\begin{itemize}
\item \texttt{PIDMAP\_TASKS}~--- все потоки в системе;
\item \texttt{PIDMAP\_PROC}~--- только процессы в системе;
\item \texttt{PIDMAP\_CHILDREN}~--- потомки определенного процесса;
\item \texttt{PIDMAP\_THREADS}~--- потоки определенного процесса.
\end{itemize}

Помимо этого, может быть передан опциональный флаг для отображения в выдаче
при использовании \texttt{PIDMAP\_PROC} или \texttt{PIDMAP\_TASKS} потоков
ядра~--- флаг \texttt{PIDMAP\_IGNORE\_KTHREADS}.

Возможность получения только потомков одного конкретного процесса является
удобной возможностью для построения дерева процессов в первую очередь для таких
программ, как \texttt{pstree}, \texttt{top} и \texttt{htop}. Идентификатор
процесса в таких случаях использования системного вызова передается в параметре
\texttt{pid}.

Параметр \texttt{pids} представляет собой указатель на заполняемый буфер в
адресном пространстве пользователя. Префикс \texttt{\_\_user} в его определении
используется для дополнительной проверки на стадии компиляции и инструментом
\texttt{sparse}, что функциям, работающим с пользовательскими указателями, не
будут переданы указатели ядра. Основными функциями  являются:
\begin{itemize}
\item \texttt{copy\_to\_user}~--- копирование произвольного числа байт в
  пространство пользователя;
\item \texttt{copy\_from\_user}~--- копирование произовального числа байт из
  пользовательского буфера в ядерный;
\item \texttt{get\_user}~--- получение значения переменной, на которую указывает
  пользовательский указатель;
\item \texttt{put\_user}~--- помещение переменной из ядра в пространство
  пользователя по переданному указателю.
\end{itemize}

Функции \texttt{get\_user} и \texttt{put\_user} отличаются тем, что копируют
только небольшие значения, способные поместиться в регистр процессора.
Перечисленные функции существуют с целью дополнительных проверок времени
выполнения, является указатель пользовательским, принадлежит ли он текущему
контексту и есть ли соответствующие права доступа на память по переданному
указателю.

В случае отсутствия префикса \texttt{\_\_user} при объявлении указателей
пространства пользователя инструментом семантических проверок Sparse
генерируется предупреждение, и при наличии подобных предупреждений патч не
примется разработчиками ядра:

\medskip
\begin{lstlisting}[style=cstyle]
# make C=1 kernel/pidmap.o
  ...
  CHECK   kernel/pidmap.c
kernel/pidmap.c:283:37: warning: incorrect type in argument 1 (different address spaces)
kernel/pidmap.c:283:37:    expected int [noderef] <asn:1>*pids
kernel/pidmap.c:283:37:    got int *pids
kernel/pidmap.c:285:45: warning: incorrect type in argument 2 (different address spaces)
kernel/pidmap.c:285:45:    expected int [noderef] <asn:1>*[assigned] upid
kernel/pidmap.c:285:45:    got int *pids
kernel/pidmap.c:287:44: warning: incorrect type in argument 2 (different address spaces)
kernel/pidmap.c:287:44:    expected int [noderef] <asn:1>*[assigned] upid
kernel/pidmap.c:287:44:    got int *pids
  CC      kernel/pidmap.o
\end{lstlisting}
\medskip

Параметры \texttt{start\_pid} и \texttt{pid\_count} выполняют функцию обеспечения
получения списка идентификаторов начиная с произвольного и определенного
количества, о чем было описано ранее.

\subsection{Системный вызов \texttt{sys\_fdmap}}

Системный вызов \texttt{sys\_fdmap} заполняет переданный пользовательской
программой буфер номерами файловых дескрипторов определенного процесса. Вызов
является заменой чтению элементов директории \texttt{/proc/\$PID}. Определение
функции из файла \texttt{include/linux/syscalls.h}:

\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_fdmap(pid_t pid,
			  int __user *fds,
			  unsigned int count,
			  int start_fd,
			  int flags);
\end{lstlisting}
\medskip

В параметре \texttt{pid} передается идентификатор процесса, номера дескрипторов
которого программа собирается получить. Для получения списка собственных
дескрипторов можно передать параметром нуль. Подобное использование вызова
работает бестрее ввиду отсутствия необходимости искать процесс среди всех.
Получение своих открытых файловых дескрипторов полезно, например, для демонов,
при старте которых важно максимально изолировать себя от окружающего
воздействия, в том числе закрыть все дескрипторы.
