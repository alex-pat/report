\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:func}

В данном разделе описывается функционирование и интерфейс между модулями
разрабатываемой системы. В первую очередь перед этим необходимо выделить и
конкретизировать необходимые для реализации критерии, составляющие
результирующие преимущества системы, а также определить путь решения
поставленных задач. К таким вопросам относятся:

\begin{itemize}
\item формат и состав структур;
\item расположение данных переменной длины;
\item возоможность пользователю определять состав получаемых данных;
\item долговечность формата данных;
\item обход контроля пространством пользователя размера выделяемой памяти.
\end{itemize}

Опишем подробнее каждый из пунктов. Как было определено ранее и как показывает
мировая практика, оптимальным форматом данных является бинарная структура, а не
текстовый поток. Кроме того, для предотвращения получения пользовательской
программой лишних данных и структурирования интерфейса системы, необходимо
логически разделить возможные передаваемые данные на подчасти. Описанные условия
будут описаны далее при описании интерфейса каждого системного вызова.

Часто при разработке интерфейсов встает задача об отпимальном размещении данных,
которые могут занимать либо крайне большие объемы памяти, либо быть вообще
неограниченными по размеру. Примерами таких данных являются имена файлов и
директорий, а также полные пути к файлам. В случае с системами семейства UNIX,
стандарт POSIX ставит достаточно высокие верхние границы размера имен: 255 байт
для имени и 4095 байт для целого пути. Очевидно, что выделять такие объемы
памяти при каждом вызове, даже если результат будет занимать заведомо мало
памяти~--- неоптимальное решение. Общепринятым решением является размещение
данных переменной длины в конце структуры, при этом размер строки указывается
равным нули или единице. Примером таких данных является структура
\texttt{linux\_dirent}, использующаяся в системном вызове \texttt{getdents()}:

\medskip
\begin{lstlisting}[style=cstyle]
struct linux_dirent {
	unsigned long	d_ino;
	unsigned long	d_off;
	unsigned short	d_reclen;
	char		d_name[1];
};
\end{lstlisting}
\medskip

В данном случае поле \texttt{d\_name} используется для хранения имени элемента
директории. Так как в языке Си строки нуль-терминированные, нет необходимости в
дополнительном поле размера имени. Подобный подход с расположением данных
переменного размера в конце структуры используется не только в случае имен и
путей к файлам, но и в случаях отпимизации выделения строк малого размера в
структуре ядра \texttt{dentry} или стандартной библиотеке языка С++. Такое
решение позволяет сэкономить не только выделенную память, но и уменьшить число
кэш-промахов во время работы со структурами, так как непосредственно строка
располагается рядом с описывающей ее структурой.

Часто пользовательской программе для выполнения своей задачи нужна только часть
предоставляемых системой данных. При частых запросах извлечение системой
избыточных данных может занимать значительную часть времени. В таких случаях
создание множества отдельных каналов получения информации для каждого случая
использования является неразумным выбором. Более предпочтительным является
предоставление пространству пользователя возможности указать, какие данные ему
нужны. Одним из способов реализации такого функционала является передача флагов.
Примером использующего флаги для описания перечня необходимых для получения
данных является системный вызов \texttt{statx()}, заполняемая структура которого
в данный момент насчитывает 19 полей. Флаги передаются в виде битовой маски.

При разработке операционной системы и ее компонентов особенно актуален вопрос
поддержки обратной совместимости. При отсутствии совместимости с предыдущими
интерфейсами перестают полноценно функционировать пользовательские программы и
драйвера. И если в случае внутренних бинарных интерфейсов ядра разработчиками
Linux принято решение в пользу переработок интерфейсов для их развития, то
интерфейс между пользовательской программой и ядром обязан быть максимально
стабильным, насколько это возможно. В противном случае операционная система не
имела бы широкой аудитории пользователей. Применяемый по этому вопросу опыт
приводит к такому результату, что программы, собранные даже на ядре версии 0.9
могут успешно  запускаться и работать на современном ядре. Это показывает
важность поддержки обратной совместимости.

В случае разработки нового интерфейса с учетом необходимости поддержки обратной
совместимости важно учитывать возможные изменения в устройстве ядра, из-за
которых перед разработчиком в будущем может встать выбор: перестать поддерживать
интерфейс, нарушив совместимость, или продолжить поддерживать старый интерфейс,
эмулируя поведение старой версии системы. Оба варианта имеют существенные
минусы: при отсутствии поддержки высока вероятность потери системой своей
аудитории, а при принудительной поддержке код системы наполняется большим
количеством избыточного кода. Подобных проблем можно избежать, изначально
проектируя интерфейсы такими, что изменения внутренней архитектуры ядра не будут
влиять на возможность и актуальность их использования. Существует несколько
аспектов проектирования подобных устойчивых интерфейсов:
\begin{itemize}
\item флаги, независимые от внутресистемных;
\item платформонезависимые типы;
\item увеличенные поля.
\end{itemize}

Важной частью разработки интерфейса системных вызовов является проектирование
способа получения данных, размер буфера для которых либо слишком большой для
того, чтобы программа пространства пользователя могла ее разово выделить, либо
слишком большая для того, чтобы ядро могло за один вызов полностью отдать, либо
размер буфера просто неизвестен заранее. При этом важно спроектировать интерфейс
таким образом, чтобы пользовательская программа не могла прямо или косвенно
контролировать размеры выделяемой ядром памяти, чтобы не создавать потенциальные
уязвимости в системе.

Для обеспечения реализации вышеописанных механизмов предпринимается несколько
действий. Во-первых, временные структуры в ядре выделяются фиксированного
размера, что обеспечит отсутствие влияния пользовательских программ на объемы
выделенной памяти. Во-вторых, для обеспечения сбора информации за несколько
вызовов обеспечивается старт сбора с произвольной позиции. Этого можно достичь
двумя способами: сохранением состояния внутри ядра или передачей начальной
позиции пользовательской программой. Первый способ менее предпочтителен ввиду
необходимости дополнительных выделений памяти под хранение состояния между
несколькими вызовами, что тянет за собой массу проблем с тем, когда такую память
освобождать. Решение в пользу ручного освобождения памяти по вызову
пространством пользователя является явной ошибкой ввиду того, что программа
может этот вызов элементарно не сделать, либо не закончить запросы данных по
множеству причин, в результате чего произойдет утечка памяти ядра, что является
серьезной проблемой, кроме того, это противоречит одному из вышеописанных
критериев: независимости выделений памяти ядра от действий пользовательской
программы. Исключением в данном случае можно назвать системный вызов
\texttt{getdents}, позиция чтения для которого хранится в поле \texttt{private}
структры \texttt{file}, однако подобный подход неприменим в рамках решаемой
задачи, так как в подразумевает открытие файла и все сопутствующие выделения.
Выбор в пользу автоматического освобождения памяти (например, по
истечению времени) также является опасным решением ввиду того, что по сути в
таком случае пользовательская программа тоже влияет на объемы выделенной памяти,
хотя и косвенно. Кроме того, автоматическое освобождение памяти требует
значительных затрат времени выполнения. Таким образом, наиболее оптимальным
вариантом передачи данных пространству пользователя является передача позиции,
например, одним из параметров. Позиция может представлять собой порядковый номер
элемента, номер байта, значение последнего прочитанного элемента или первого
элемента для чтения.

Для простых системных вызовов, которые принимают мало аргументов,
предпочтительным способом обеспечения будущей расширяемости является включение
аргумента \texttt{flags} в системный вызов. Чтобы убедиться, что программы
пользовательского пространства могут безопасно использовать флаги между версиями
ядра, необходимо проверять, содержит ли значение \texttt{flags} какие-либо
неизвестные флаг, и возвращать значение \texttt{-EINVAL} в случае ошибки:

\medskip
\begin{lstlisting}[style=cstyle]
if (flags & ~(THING_FLAG1 | THING_FLAG2 | THING_FLAG3))
	return -EINVAL;
\end{lstlisting}
\medskip

В случае более сложных системных вызовов, которые включают большее количество
аргументов, предпочтительно инкапсулировать большинство аргументов в структуру,
которая передается по указателю указателем. Такая структура может также
безопасно обработать будущее расширение за счет включения аргумента размера в
структуру:

\medskip
\begin{lstlisting}[style=cstyle]
struct xyzzy_params {
	u32 size;
	u32 param_1;
	u64 param_2;
	u64 param_3;
};
\end{lstlisting}
\medskip

Поскольку любое добавленное впоследствии поле, например \texttt{param\_4},
спроектировано таким образом, что нулевое значение дает поведение предыдущей
версии структуры, то это позволяет существовать несоответствиям различного типа:
\begin{itemize}
\item чтобы справиться с ситуацией вызова более поздней программой более старого
  ядра, код ядра должен проверять, что любая память, превышающая размер
  структуры, которую она ожидает, равна нулю;
\item для корректной обработки ситуации вызова более старой программой более
  нового ядра, код ядра может проверять значения поля с размером структуры.
\end{itemize}

Если новый системный вызов управляет процессом, отличным от вызывающего
процесса, его возможности следует ограничить (используя функцию
\texttt{ptrace\_may\_access()}), так что только вызывающий процесс с теми же
правами, что и целевой процесс, или процесс с администраторскими правами, могут
манипулировать целевым процессом.

Наконец, необходимо иметь в виду, что некоторые архитектуры, отличные от x86,
могут выполняться несколько быстрее, если параметры системного вызова, которые
явно описаны 64-разрядными, попадают на аргументы с нечетным номером, из-за
использования смежных пар 32-разрядных регистров. Данный момент не проявляется,
если аргументы являются частью структуры, передаваемой по указателю.

При разработке ядра Linux принято разделять и хранить в отдельных местах
заголовочные файлы, используемые только для кода ядра, и файлы, которыми будут
пользоваться разработчики пользовательских программ. Такой подход делает
архитектуру ядра более структурированным и поддерживаемым, что крайне важно при
разработке любой программы, в особенности, и ядра операционной системы.
Заголовочные файлы второго типа (интерфейс пользователя) располагается в
директории \texttt{include/uapi/}. Каждый файл в поддиректориях содержит
определения структур, констант и функций. Содержимое файлов принято не изменять,
а только дополнять, чтобы сохранять обратную совместимость. Поддиректории
предназначены для подсистем звука, видео, интерфейса SCSI, гипервизора XEN,
общесистемных и других заголовков.

Таблицы системных вызовов расположены в соответствующих архитектурам
поддиректориях \texttt{arch/}, например, для архитектуры x86\_64 таблица
расположена в файле \texttt{arch/x86/entry/syscalls/syscall\_64.tbl}.
Файл представляет собой простую текстовую таблицу, в которой содержатся
номера системных вызовов, тип бинарного интерефейса, имя вызова и имя символа
обработчика системного вызова. В процессе сборки ядра таблица парсится
bash-скриптом, который генерирует из нее файл на языке ассемблера. Такой подход
позволяет избежать совершения разработчиками случайных ошибок при дополнении
ассемблерного кода во время разработки новых системных вызовов. Несмотря на то,
что таблица находится не в директории \texttt{include/uapi/}, файл также не
изменяется, а лишь дополняется, так как номера системных вызовов являются
важнейшей частью пользовательского интерфейса ядра.

\subsection{Системный вызов \texttt{sys\_pidmap}}

Системный вызов \texttt{sys\_pidmap} возвращает список идентификаторов
существующих в данный момент в системе процессов и потоков. Иными словами,
заполняет переданный пользовательской программой буфер идентификаторами. Вызов
является расширенной заменой прохождению по директории \texttt{/proc/}. Прототип
обработчика вызова:

\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_pidmap(pid_t pid,
			   int __user *pids,
			   unsigned int pids_count,
			   unsigned int start_pid,
			   int flags);
\end{lstlisting}
\medskip

В зависимости от того, какие данные нужны пространству пользователя, программа
передает одно из следующих значений в параметр \texttt{flags}:

\begin{itemize}
\item \texttt{PIDMAP\_TASKS}~--- все потоки в системе;
\item \texttt{PIDMAP\_PROC}~--- только процессы в системе;
\item \texttt{PIDMAP\_CHILDREN}~--- потомки определенного процесса;
\item \texttt{PIDMAP\_THREADS}~--- потоки определенного процесса.
\end{itemize}

Помимо этого, может быть передан опциональный флаг для отображения в выдаче
при использовании \texttt{PIDMAP\_PROC} или \texttt{PIDMAP\_TASKS} потоков
ядра~--- флаг \texttt{PIDMAP\_IGNORE\_KTHREADS}.

Возможность получения только потомков одного конкретного процесса является
удобной возможностью для построения дерева процессов в первую очередь для таких
программ, как \texttt{pstree}, \texttt{top} и \texttt{htop}. Идентификатор
процесса в таких случаях использования системного вызова передается в параметре
\texttt{pid}.

Параметр \texttt{pids} представляет собой указатель на заполняемый буфер в
адресном пространстве пользователя. Префикс \texttt{\_\_user} в его определении
используется для дополнительной проверки на стадии компиляции и инструментом
\texttt{sparse}, что функциям, работающим с пользовательскими указателями, не
будут переданы указатели ядра. Основными функциями  являются:
\begin{itemize}
\item \texttt{copy\_to\_user}~--- копирование произвольного числа байт в
  пространство пользователя;
\item \texttt{copy\_from\_user}~--- копирование произовального числа байт из
  пользовательского буфера в ядерный;
\item \texttt{get\_user}~--- получение значения переменной, на которую указывает
  пользовательский указатель;
\item \texttt{put\_user}~--- помещение переменной из ядра в пространство
  пользователя по переданному указателю.
\end{itemize}

Функции \texttt{get\_user} и \texttt{put\_user} отличаются тем, что копируют
только небольшие значения, способные поместиться в регистр процессора.
Перечисленные функции существуют с целью дополнительных проверок времени
выполнения, является указатель пользовательским, принадлежит ли он текущему
контексту и есть ли соответствующие права доступа на память по переданному
указателю.

В случае отсутствия префикса \texttt{\_\_user} при объявлении указателей
пространства пользователя инструментом семантических проверок Sparse
генерируется предупреждение, и при наличии подобных предупреждений патч не
примется разработчиками ядра:

\medskip
\begin{lstlisting}[style=cstyle]
# make C=1 kernel/pidmap.o
  ...
  CHECK   kernel/pidmap.c
kernel/pidmap.c:283:37: warning: incorrect type in argument 1 (different address spaces)
kernel/pidmap.c:283:37:    expected int [noderef] <asn:1>*pids
kernel/pidmap.c:283:37:    got int *pids
kernel/pidmap.c:285:45: warning: incorrect type in argument 2 (different address spaces)
kernel/pidmap.c:285:45:    expected int [noderef] <asn:1>*[assigned] upid
kernel/pidmap.c:285:45:    got int *pids
kernel/pidmap.c:287:44: warning: incorrect type in argument 2 (different address spaces)
kernel/pidmap.c:287:44:    expected int [noderef] <asn:1>*[assigned] upid
kernel/pidmap.c:287:44:    got int *pids
  CC      kernel/pidmap.o
\end{lstlisting}
\medskip

Параметры \texttt{start\_pid} и \texttt{pid\_count} выполняют функцию обеспечения
получения списка идентификаторов начиная с произвольного и определенного
количества, о чем было описано ранее.

Существует возможность компиляции ядра без вызова \texttt{sys\_pidmap} путём
отключения опции компиляции \texttt{CONFIG\_PIDMAP}.

\subsection{Системный вызов \texttt{sys\_pidinfo}}

Системный вызов \texttt{sys\_pidinfo} предназначен для передачи пользовательской
программе общей информации о конкретном процессе, представляя собой альтернативу
части файлов \texttt{/proc/\$PID/status} и \texttt{/proc/\$PID/stat}. Прототип
обработчика:

\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_pidinfo(pid_t pid, unsigned long mode,
			    struct taskinfo __user *buffer);
\end{lstlisting}
\medskip

Параметр \texttt{mode} зарезервирован для будущего использования и должен быть
равен нулю. Ядро во время вызова заполняет структуру \texttt{taskinfo}, имеющую
следущее определение:

\medskip
\begin{lstlisting}[style=cstyle]
struct taskinfo {
	/* 0x00 */
	char comm[TASKINFO_COMM_LEN];
	/* 0x20 */
	__u32	state;
	__u32	umask;
	__u32	tgid;
	__u32	ngid;
	/* 0x30 */
	__u64	utime;
	__u64	stime;
	__u64	cutime;
	__u64	cstime;
	/* 0x50 */
	__u32	pid;
	__u32	ppid;
	__u32	tracer_id;
	__u32	num_threads;
};
\end{lstlisting}
\medskip

Поле \texttt{comm} предоставляет значение одноимённого поля из структуры задачи
\texttt{task\_struct}, то есть комментарий или имя команды, связанное с
задачей. Различные потоки в одном и том же процессе могут иметь разные значения
\texttt{comm}. Данное значение также доступно из файла
\texttt{/proc/\$PID/comm}. Поток может изменить значение \texttt{comm} у себя
или любого другого потока в той же группе потоков путем записи в файл
\texttt{/proc/self/task/\$TID/comm}. В текущий момент размер строки составляет
16 байт, однако уже предпринимались попытки увеличения её размера, поэтому было
принято решение в структуре \texttt{taskinfo} соответствующее поле установить
размером в 32 байта. Подобное решение уже было осуществлено в интерфейсе
\texttt{taskstats}.

Поле \texttt{state} описывает состояние задачи и имеет одно из следующих
значений:
\begin{itemize}
\item \texttt{TASKINFO\_STATE\_RUNNING};
\item \texttt{TASKINFO\_STATE\_SLEEPING};
\item \texttt{TASKINFO\_STATE\_DISK\_SLEEP};
\item \texttt{TASKINFO\_STATE\_STOPPED};
\item \texttt{TASKINFO\_STATE\_TRACED};
\item \texttt{TASKINFO\_STATE\_DEAD};
\item \texttt{TASKINFO\_STATE\_ZOMBIE};
\item \texttt{TASKINFO\_STATE\_PARKED};
\item \texttt{TASKINFO\_STATE\_IDLE}.
\end{itemize}

Поле \texttt{umask} содержит значение маски, которую процесс использует при
создании файлов. Получается и узнаётся для себя системным вызовом
\texttt{umask()}. Вызов принимает новое значение маски и возвращает старое.
Другими словами, получение маски другого процесса в бинарном виде недоступно.
В текстовом виде это возможно в файлах \texttt{stat} и \texttt{status} в
соответствующих директориях, описывающих потоки или процессы.

В бинарном виде чтение \texttt{umask} без изменения осуществляется двумя
вызовами системного вызова, передачей второму вызову значения, возвращенного
первым. Подобная необходимость в неатомарном выполнении двух шагов может
приводить к состоянию гонок в многопоточных программах. Начиная с ядра версии
4.7 доступна возомжность чтения значения без изменения из файла, однако это
требует дополнительных накладных расходов на открытие и закрыние файлов, чтение
и парсинг текста.

Параметр \texttt{umask} также влияет на права, назначенные объектам
межпроцессного взаимодействия POSIX, таких как очереди сообщений (системный
вызов \texttt{mq\_open()}), именованные семафоры (\texttt{sem\_open()}),
объекты разделяемой памяти (\texttt{shm\_open()}), именованные каналы
(\texttt{mkfifo()}) и сокеты UNIX. При этом, \texttt{umask} не влияет на права,
назначенные созданным процессом объектам межпроцессного взаимодействия System V:
очереди сообщений (\texttt{msgget()}), семафоры (\texttt{semget()}) и сегменты
разделяемой памяти (\texttt{shmget()}).

Поля \texttt{tgid} и \texttt{ngid} содержат соответственно идентификатор группы
потоков (процесса) и идентификатор группы NUMA.

Поле \texttt{utime} содержит количество времени, в течение которого этот процесс
или поток был запланирован в режиме пользователя, в тактах часов.

Поле \texttt{stime} содержит количество времени, в течение которого этот процесс
был запланирован в режиме ядра, делённое на значение \texttt{\_SC\_CLK\_TCK}.

Количество времени ожидания процесса дочерних процессов, запланированных в
пользовательском режиме, а также для процессов в режиме ядра, содержится
соответственно в полях \texttt{cutime} и \texttt{cstime}.

Поле \texttt{tracer\_id} подержит идентификатор процесса, осуществляющего
трейсинг исследуемого процесса. Такая возможность полезна для таких утилит, как
\texttt{strace}, \texttt{ltrace} и других.

Утилита \texttt{strace} перехватывает и логирует системные вызовы, вызываемые
процессом, а также сигналы, полученные процессом. Имя каждого системного вызова,
его аргументы и возвращаемое значение печатаются с стандартный поток ошибок либо
в файл:

\medskip
\begin{lstlisting}[style=cstyle]
[pid 28772] select(4, [3], NULL, NULL, NULL <unfinished ...>
[pid 28779] clock_gettime(CLOCK_REALTIME, {1130322148, 939977000}) = 0
[pid 28772] <... select resumed> )      = 1 (in [3])
\end{lstlisting}
\medskip

Информация о библиотечных вызовах процесса генерируется утилитой
\texttt{ltrace}. Как и в случае с \texttt{strace}, важно знать, что исследуемый
процесс не исследуется в данный момент ещё кем-то, из-за того, что ядро Linux
попускает только один следящий процесс. Такое состояние делает актуальным
наличие поля \texttt{tracer\_id} в структуре \texttt{taskinfo}.

Поле \texttt{num\_theads} содержит число потоков текущего процесса.
Конфигурационной опцией \texttt{CONFIG\ PIDINFO}.

\subsection{Системный вызов \texttt{sys\_fdmap}}

Системный вызов \texttt{sys\_fdmap} заполняет переданный пользовательской
программой буфер номерами файловых дескрипторов определенного процесса. Вызов
является заменой чтению элементов директории \texttt{/proc/\$PID}. Определение
функции из файла \texttt{include/linux/syscalls.h}:

\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_fdmap(pid_t pid,
			  int __user *fds,
			  unsigned int count,
			  int start_fd,
			  int flags);
\end{lstlisting}
\medskip

В параметре \texttt{pid} передается идентификатор процесса, номера дескрипторов
которого программа собирается получить. Для получения списка собственных
дескрипторов можно передать параметром нуль. Подобное использование вызова
работает бестрее ввиду отсутствия необходимости искать процесс среди всех.
Получение своих открытых файловых дескрипторов полезно, например, для демонов,
при старте которых важно максимально изолировать себя от окружающего
воздействия, в том числе закрыть все дескрипторы. Кроме того, получение списка
собственных дескрипторов полезно для утилит, закрывающих все дескрипторы, кроме
стандартного ввода, вывода и ошибки:
\begin{itemize}
\item набор демонов Samba для поддержки протокола SMB в Linux при инициализации
  открывает файл \texttt{/dev/null}, так как по стандарту POSIX системный вызов
  \texttt{open()} возвращает минимальный доступный дескриптор. Такое решение
  является избыточным и ненадежным, так как не исключено существование файлов, с
  дескриптором выше полученного, если, например, родительский процесс открыл
  множество файлов, а незадолго до запуска демона закрыл один из первых из них;
\item утилита \texttt{lsof} в начале запуска старается закрыть все открытые
  файлы (в первую очередь, унаследованные от родительского процесса), кроме
  stdin, stdout, stderr. Для этого, если целевая платформа не поддерживает
  надёжных методов определения значения максимального открытого дескриптора,
  просто закрывает все до значения 50. Такое решение также ненадёжно, а также
  избыточно ввиду лишних вызовов \texttt{close}.
\end{itemize}

Особенности других параметров были описаны при описании вызова
\texttt{sys\_pidmap}:
\begin{itemize}
\item \texttt{fds}~--- указатель на буфер пространства пользователя;
\item \texttt{count}~--- размер буфера в элементах;
\item \texttt{start\_fd}~--- значение начального дескриптора;
\item \texttt{flags}~--- флаги, зарезервировано для будущего использования,
  в данный момент принимается только значение 0.
\end{itemize}

В типичном случае испольозвания системного вызова (демон закрывает все открытые
файлы), примерный код будет выглядеть так:

\medskip
\begin{lstlisting}[style=cstyle]
int close_pids(void)
{
	int buf[BUF_SIZE], start_fd = 0;
	long ret;

	for ( ; ; ) {
		ret = fdmap(0, buf, sizeof(buf), start_fd, 0);
		if (ret < 0) {
			perror("fdmap");
			break;
		}

		for (int i = 0; i < ret; i++) {
			if (close(buf[i])) {
				int err = errno;
				perror("close");
				return -errno;
			}
		}
		start_fd = buf[ret-1];
	}
	return -ret;
}
\end{lstlisting}
\medskip

При необходимости возможно исключить системный вызов из ядра отключением опции
компиляции \texttt{CONFIG\_FDMAP}. Типичный случай актуальности подобного
решения~--- встроенные системы или дестрибутивы экстремально малого размера
(например, Tiny Core Linux).

Реализация обработчика системного вызова \texttt{sys\_fdmap} расположена в файле
\texttt{fs/file.c} исходный кодов ядра ввиду использования статических функций
этого файла, таких как 

\subsection{Системный вызов \texttt{sys\_pidfdopen}}

Вызов \texttt{sys\_pidfdopen} позволяет процессу с достаточным количеством прав
переоткрыть для себя файл, открытый другим процессом, по номеру дескриптора.
Такое поведение является заменой открытию виртуального файла
\texttt{/proc/\$PID/fd/\$FD}. Определение функции: 

\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_pidfdopen(pid_t pid, int fd, int flags);
\end{lstlisting}
\medskip

Параметры \texttt{pid} и \texttt{fd} являются соответственно идентификаторами
исследуемного процесса и номером файлового дескриптора, а параметр
\texttt{flags} аналогичен одноименному параметру системного вызова
\texttt{open()} и дожен содержать одно из слущующих флагов режимов открытия:
\begin{itemize}
\item \texttt{O\_RDONLY}~--- открытие только для чтения;
\item \texttt{O\_WRONLY}~--- открытие только для записи;
\item \texttt{O\_RDWR}~--- открытие для чтения и записи.
\end{itemize}

Кроме того, путем осуществления операции побитовой конъюнкции могут быть
переданы такие флаги, как:
\begin{itemize}
\item \texttt{O\_APPEND}~--- файл открывается в режиме добавления. Перед каждой
  записью (системный вызов \texttt{write()}) смещение файла смещается на конец
  файка, как при вызове \texttt{lseek()} c флагом \texttt{SEK\_END}. Модификация
  смещения файла и операция записи выполняются как один атомный шаг. Однако,
  использование флага может привести к повреждению файлов на сетевой файловой
  системе, если более одного процесса одновременно дописывают дынне в файл. Это
  связано с тем, что NFS не поддерживает добавление данных в конец файла,
  поэтому ядро клиента должно имитировать его, что невозможно сделать без угрозы
  состояния гонки;
\item \texttt{O\_DIRECT}~--- попытаться минимизировать кеш-эффекты операций с
  файлом. В целом, это ухудшит производительность, однако бывает полезно в
  особых ситуациях, например, когда приложения выполняют собственное
  кэширование. Файловый ввод-вывод выполняется непосредственно через буферы в
  пользовательском пространстве. Примером акуальности использования такого флага
  являются базы данных.
\item \texttt{O\_DIRECTORY}~--- файл открывается как каталог. Если открываемый
  файл каталогом не являестя, это приведет к сбою открытия. Флаг был добавлен в
  версию ядра 2.1.126, чтобы избежать проблем с отказами в обслуживании, при
  вызове \texttt{opendir()} вызывается на канале или ленточном устройстве.
\item \texttt{O\_LARGEFILE}~--- открыть файл, размер которого не может быть
  размещен в четырехбайном типе \texttt{off\_t}, вместо этого, файл отрывается с
  применением восьмибайтного типа \texttt{off64\_t}. При этом до включения любых
  файлов заголовков должен быть определен макрос \texttt{\_LARGEFILE64\_SOURCE}.
  Однако, установка макроса \texttt{\_FILE\_OFFSET\_BITS} равным 64, вместо
  использования \texttt{O\_LARGEFILE}, является предпочтительным методом доступа
  к большим файлам в 32-разрядных системах.
\end{itemize}

Кроме того, стоит отметить, что передача флагов открытия, таких как
\texttt{O\_CREAT}, \texttt{S\_IRWXU}, \texttt{S\_IRUSR}, \texttt{S\_IWUSR} и
других, вызову, открывающему уже открытый файл, лишена смысла.

Системный вызов может возвратить одну из нескольких ошибок:
\begin{itemize}
\item \texttt{EINVAL}~--- неверный параметр;
\item \texttt{ESRCH}~--- процесс не найден;
\item \texttt{EBADF}~--- файл не найден;
\item \texttt{EBADF}~--- файл не найден;
\item \texttt{EACCESS}~--- недостаточно прав для открытия.
\end{itemize}

Возможен возврат также других ошибок, в первую очередь, возвращаемых вызовом
\texttt{open()}.

\subsection{Системный вызов \texttt{sys\_pidfdinfo}}

Системный вызов \texttt{sys\_pidfdinfo} предназначен для получения информации об
открытом файле конкретного процесса, представляя своей функциональностью
альтернативу файлу \texttt{/proc/\$PID/fdinfo/\$FD} и чтению символьной ссылки 
\texttt{/proc/\$PID/fd/\$FD}. Определение функции:

\medskip
\begin{lstlisting}[style=cstyle]
asmlinkage long sys_pidfdinfo(pid_t pid,
			      int fd,
			      struct fdinfo __user *buffer,
			      unsigned int size);
\end{lstlisting}
\medskip

Вызовом наполняется структура \texttt{fdinfo}, имеющая следующее определение:

\medskip
\begin{lstlisting}[style=cstyle]
struct fdinfo {
	__u64	pos;
	__u64	flags;
	char	path[1];
};
\end{lstlisting}
\medskip

Структура содержит позицию в файле, флаги состояния файла и путь к файлу. Конец
струкуры объявлен с динамическим размером, ввиду того, что пространству
пользователя может быть не нужно выделять большие объёмы данных под путь. По
этой причине последним параметров в вызов передается размер выделенного
пользовательской программой буфера со структурой.

В поле \texttt{flags} могут находиться следующие флаги:
\begin{itemize}
\item \texttt{FDINFO\_RDONLY};
\item \texttt{FDINFO\_WRONLY};
\item \texttt{FDINFO\_RDWR};
\item \texttt{FDINFO\_CREAT}; 
\item \texttt{FDINFO\_EXCL};
\item \texttt{FDINFO\_NOCTTY};
\item \texttt{FDINFO\_TRUNC};
\item \texttt{FDINFO\_APPEND};
\item \texttt{FDINFO\_NONBLOCK};
\item \texttt{FDINFO\_DSYNC};
\item \texttt{FDINFO\_FASYNC};
\item \texttt{FDINFO\_DIRECT};
\item \texttt{FDINFO\_LARGEFILE};
\item \texttt{FDINFO\_DIRECTORY};
\item \texttt{FDINFO\_NOFOLLOW};
\item \texttt{FDINFO\_NOATIME};
\item \texttt{FDINFO\_CLOEXEC};
\item \texttt{FDINFO\_SYNC};
\item \texttt{FDINFO\_PATH};
\item \texttt{FDINFO\_TMPFILE};
\item \texttt{FDINFO\_FD\_DELETED}.
\end{itemize}

Почти все данные флаги соответствуют флагам системного вызова \texttt{open()}.
Существование отдельных флагов для этого объясняется стремлением обеспечить
стабильность интерфейса. При этом отдельного внимания заслуживает флаг
\texttt{FDINFO\_FD\_DELETED}, означающий, что файл, открытый другим процессом,
уже удалён.
